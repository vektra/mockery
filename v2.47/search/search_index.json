{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mockery","text":"<p>Mockery is a project that creates mock implementations of Golang interfaces. The mocks generated in this project are based off of the github.com/stretchr/testify suite of testing packages.</p> <p> </p>"},{"location":"#why-mockery","title":"Why mockery?","text":"<p>When you have an interface like this:</p> db.go<pre><code>type DB interface {\n    Get(val string) string\n}\n</code></pre> <p>and a function that takes this interface:</p> db_getter.go<pre><code>func getFromDB(db DB) string {\n    return db.Get(\"ice cream\")\n}\n</code></pre> <p>You can test <code>getFromDB</code> by either instantiating a testing database, or you can simply create a mock implementation of <code>DB</code> using mockery. Mockery can automatically generate a mock implementation that allows us to define assertions on how the mock was used, what to return, and other useful tidbits. We can add a <code>//go:generate</code> directive above our interface:</p> db.go<pre><code>//go:generate mockery --name DB\ntype DB interface {\n    Get(val string) string\n}\n</code></pre> .mockery.yaml<pre><code>inpackage: True # (1)!\nwith-expecter: True # (2)!\ntestonly: True # (3)!\n</code></pre> <ol> <li>Generate our mocks next to the original interface</li> <li>Create expecter methods</li> <li>Append <code>_test.go</code> to the filename so the mock object is not packaged </li> </ol> Bash<pre><code>$ go generate  \n05 Mar 23 21:49 CST INF Starting mockery dry-run=false version=v2.20.0\n05 Mar 23 21:49 CST INF Using config: .mockery.yaml dry-run=false version=v2.20.0\n05 Mar 23 21:49 CST INF Walking dry-run=false version=v2.20.0\n05 Mar 23 21:49 CST INF Generating mock dry-run=false interface=DB qualified-name=github.com/vektra/mockery/v2/pkg/fixtures/example_project version=v2.20.0\n</code></pre> <p>We can then use the mock object in a test:</p> db_getter_test.go<pre><code>import (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_getFromDB(t *testing.T) {\n    mockDB := NewMockDB(t)\n    mockDB.EXPECT().Get(\"ice cream\").Return(\"chocolate\").Once()\n    flavor := getFromDB(mockDB)\n    assert.Equal(t, \"chocolate\", flavor)\n}\n</code></pre>"},{"location":"#why-use-mockery-over-gomock","title":"Why use mockery over gomock?","text":"<ol> <li>mockery provides a much more user-friendly API and is less confusing to use</li> <li>mockery utilizes <code>testify</code> which is a robust and highly feature-rich testing framework</li> <li>mockery has rich configuration options that allow fine-grained control over how your mocks are generated</li> <li>mockery's CLI is more robust, user-friendly, and provides many more options</li> <li>mockery supports generics (this may no longer be an advantage if/when gomock supports generics)</li> </ol>"},{"location":"#who-uses-mockery","title":"Who uses mockery?","text":"<ul> <li> Grafana </li> <li> Google Skia </li> <li> Google Skyzkaller </li> <li> Hashicorp </li> <li> Uber Cadence </li> <li> Jaegertracing </li> <li> Splunk kafka-mq-go </li> <li> </li> <li> </li> <li> </li> <li></li> <li> eksctl </li> <li> </li> <li> Task <li> <p>Get Started</p>"},{"location":"changelog/","title":"Changelog","text":"<p>This changelog describes major feature additions. Please view the <code>releases</code> page for more details on commits and minor changes.</p>"},{"location":"changelog/#v2290-template-functions","title":"<code>v2.29.0</code> template functions","text":"<p>This release adds a large number of template functions available for use in the <code>packages</code> templating engine.</p>"},{"location":"changelog/#v2250-recursive-config","title":"<code>v2.25.0</code> <code>recursive</code> config","text":"<p>The <code>recursive</code> parameter allows mockery to dynamically discover sub-packages when using the <code>packages</code> config.</p>"},{"location":"changelog/#v2240-exclude-config","title":"<code>v2.24.0</code> <code>exclude</code> config","text":"<p>The <code>exclude</code> parameter allows you to define subpaths to ignore. This is currently only compatible when using non-<code>packages</code> config.</p>"},{"location":"changelog/#v2230-replace-types","title":"<code>v2.23.0</code> Replace Types","text":"<p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p>"},{"location":"changelog/#v2210-packages-configuration","title":"<code>v2.21.0</code>: <code>packages</code> configuration","text":"<p>In this version we release the <code>packages</code> configuration section. This new parameter allows defining specific packages to generate mocks for, while also giving fine-grained control over which interfaces are mocked, where they are located, and how they are configured. Details are provided here.</p> <p>Community input is desired before we consider deprecations of dynamic walking (via <code>all: True</code>): https://github.com/vektra/mockery/discussions/549</p>"},{"location":"changelog/#v2200-improved-return-value-functions","title":"<code>v2.20.0</code>: Improved Return Value Functions","text":"<p>Return value functions that return an entire method's return value signature can now be provided.</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) (string, error) {\n        return s, nil\n    }\n)\n</code></pre> <p>You may still use the old way where one function is provided for each return value:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) string {\n        return s\n    },\n    func(ctx context.Context, s string) error {\n        return nil\n    },\n)\n</code></pre>"},{"location":"changelog/#2190-inpackage-suffix-option","title":"<code>2.19.0</code>: <code>inpackage-suffix</code> option","text":"<p>When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks</p>"},{"location":"changelog/#v2160-config-search-path","title":"<code>v2.16.0</code>: Config Search Path","text":"<p>Mockery will iteratively search every directory from the current working directory up to the root path for a <code>.mockery.yaml</code> file, if one is not explicitly provided.</p>"},{"location":"changelog/#v2130-generics-support","title":"<code>v2.13.0</code>: Generics support","text":"<p>Mocks are now capable of supporting Golang generics.</p>"},{"location":"changelog/#v2110-mock-constructors","title":"<code>v2.11.0</code>: Mock constructors","text":"<p>Mockery v2.11 introduces constructors for all mocks. This makes instantiation and mock registration a bit easier and less error-prone (you won't have to worry about forgetting the <code>AssertExpectations</code> method call anymore).</p> <p>Before v2.11: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>After v2.11: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically - The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method. - The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</p>"},{"location":"changelog/#v2100-expecter-structs","title":"<code>v2.10.0</code>: Expecter Structs","text":"<p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre></p> <p>You can use the type-safe expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\nrequesterMock.EXPECT().\n    Get(mock.Anything).\n    Run(func(path string) { fmt.Println(path, \"was called\") }).\n    // Can still use return functions by getting the embedded mock.Call\n    Call.Return(func(path string) string { return \"result for \" + path }, nil)\n</code></pre></p>"},{"location":"changelog/#v200-major-update","title":"<code>v2.0.0</code>: Major Update","text":"<p>This is the first major update of mockery. Version 2 brings a handful of improvements to mockery:</p> <ul> <li>Structured and pretty console logging</li> <li>CLI now switches over to sp13/cobra</li> <li>Use of viper configuration parsing. You can now use a .mockery.yaml config file in your repository</li> <li>Various CI fixes and improvements</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>mockery uses spf13/viper under the hood for its configuration parsing. </p>"},{"location":"configuration/#merging-precedence","title":"Merging Precedence","text":"<p>The configuration applied to a specific mocked interface is merged according to the following precedence (in decreasing priority):</p> <ol> <li>Interface-specific config in <code>.mockery.yaml</code></li> <li>Package-specific config in <code>.mockery.yaml</code></li> <li>Command-line options</li> <li>Environment variables</li> <li>Top-level defaults in <code>.mockery.yaml</code></li> </ol>"},{"location":"configuration/#formatting","title":"Formatting","text":"<p>If a parameter is named <code>with-expecter</code> and we want a value of <code>True</code>, then these are the formats for each source:</p> source value command line <code>--with-expecter=true</code> Environment variable <code>MOCKERY_WITH_EXPECTER=True</code> yaml <code>with-expecter: True</code>"},{"location":"configuration/#recommended-basic-config","title":"Recommended Basic Config","text":"<p>Copy the recommended basic configuration to a file called <code>.mockery.yaml</code> at the top-level of your repo:</p> .mockery.yaml<pre><code>with-expecter: true\npackages:\n    github.com/your-org/your-go-project:\n        # place your package-specific config here\n        config:\n        interfaces:\n            # select the interfaces you want mocked\n            Foo:\n                # Modify package-level config for this specific interface (if applicable)\n                config:\n</code></pre> <p>mockery will search upwards from your current-working-directory up to the root path, so the same configuration should be able to follow you within your project.</p> <p>See the <code>features</code> section for more details on how the config is structured.</p>"},{"location":"configuration/#parameter-descriptions","title":"Parameter Descriptions","text":"<p>new style <code>packages</code> config</p> <p>The <code>packages</code> config section is the new style of configuration. All old config semantics, including <code>go:generate</code> and any config files lacking the <code>packages</code> section is officially deprecated as of v2.31.0. Legacy semantics will be completely removed in v3.</p> <p>Please see the features section for more details on how <code>packages</code> works, including some example configuration.</p> <p>Please see the migration docs for details on how to migrate your config.</p> name templated default description <code>all</code> <code>false</code> Generate all interfaces for the specified packages. <code>boilerplate-file</code> <code>\"\"</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>config</code> <code>\"\"</code> Set the location of the mockery config file. <code>dir</code> <code>\"mocks/{{.PackagePath}}\"</code> The directory where the mock file will be outputted to. <code>disable-config-search</code> <code>false</code> Disable searching for configuration files <code>disable-func-mocks</code> <code>false</code> Disable generation of function mocks. <code>disable-version-string</code> <code>false</code> Disable the version string in the generated mock files. <code>dry-run</code> <code>false</code> Print the actions that would be taken, but don't perform the actions. <code>exclude</code> <code>[]</code> Specify subpackages to exclude when using <code>recursive: True</code> <code>exclude-regex</code> <code>\"\"</code> When set along with <code>include-regex</code>, then interfaces which match <code>include-regex</code> but also match <code>exclude-regex</code> will not be generated. If <code>all</code> is set, or if <code>include-regex</code> is not set, then <code>exclude-regex</code> has no effect. <code>filename</code> <code>\"mock_{{.InterfaceName}}.go\"</code> The name of the file the mock will reside in. <code>include-auto-generated</code> <code>true</code> Set to <code>false</code> if you need mockery to skip auto-generated files during its recursive package discovery. When set to <code>true</code>, mockery includes auto-generated files when determining if a particular directory is an importable package. <code>include-regex</code> <code>\"\"</code> When set, only interface names that match the expression will be generated. This setting is ignored if <code>all: True</code> is specified in the configuration. To further refine the interfaces generated, use <code>exclude-regex</code>. <code>inpackage</code> <code>false</code> When generating mocks alongside the original interfaces, you must specify <code>inpackage: True</code> to inform mockery that the mock is being placed in the same package as the original interface. <code>log-level</code> <code>\"info\"</code> Set the level of the logger <code>mock-build-tags</code> <code>\"\"</code> Set the build tags of the generated mocks. Read more about the format. <code>mockname</code> <code>\"Mock{{.InterfaceName}}\"</code> The name of the generated mock. <code>outpkg</code> <code>\"{{.PackageName}}\"</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>packages</code> <code>null</code> A dictionary containing configuration describing the packages and interfaces to generate mocks for. <code>print</code> <code>false</code> Use <code>print: True</code> to have the resulting code printed out instead of written to disk. <code>recursive</code> <code>false</code> When set to <code>true</code> on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. <code>replace-type</code> <code>null</code> Replaces aliases, packages and/or types during generation. <code>tags</code> <code>\"\"</code> A space-separated list of additional build tags to load packages. <code>with-expecter</code> <code>true</code> Use <code>with-expecter: True</code> to generate <code>EXPECT()</code> methods for your mocks. This is the preferred way to set up your mocks."},{"location":"configuration/#layouts","title":"Layouts","text":"<p>Using different configuration parameters, we can deploy our mocks on-disk in various ways. These are some common layouts:</p> <p>layouts</p> defaultsadjacent to interface YAML<pre><code>filename: \"mock_{{.InterfaceName}}.go\"\ndir: \"mocks/{{.PackagePath}}\"\nmockname: \"Mock{{.InterfaceName}}\"\noutpkg: \"{{.PackageName}}\"\n</code></pre> <p>If these variables aren't specified, the above values will be applied to the config options. This strategy places your mocks into a separate <code>mocks/</code> directory.</p> <p>Interface Description</p> name value <code>InterfaceName</code> <code>MyDatabase</code> <code>PackagePath</code> <code>github.com/user/project/pkgName</code> <code>PackageName</code> <code>pkgName</code> <p>Output</p> <p>The mock will be generated at:</p> Text Only<pre><code>mocks/github.com/user/project/pkgName/mock_MyDatabase.go\n</code></pre> <p>The mock file will look like:</p> Go<pre><code>package pkgName\n\nimport mock \"github.com/stretchr/testify/mock\"\n\ntype MockMyDatabase struct {\n  mock.Mock\n}\n</code></pre> <p>Warning</p> <p>Mockery does not protect against modifying original source code. Do not generate mocks using this config with uncommitted code changes.</p> YAML<pre><code>filename: \"mock_{{.InterfaceName}}.go\"\ndir: \"{{.InterfaceDir}}\"\nmockname: \"Mock{{.InterfaceName}}\"\noutpkg: \"{{.PackageName}}\"\ninpackage: True\n</code></pre> <p>Instead of the mocks being generated in a different folder, you may elect to generate the mocks alongside the original interface in your package. This may be the way most people define their configs, as it removes circular import issues that can happen with the default config.</p> <p>For example, the mock might be generated along side the original source file like this:</p> Text Only<pre><code>./path/to/pkg/db.go\n./path/to/pkg/mock_MyDatabase.go\n</code></pre> <p>Interface Description</p> name value <code>InterfaceName</code> <code>MyDatabase</code> <code>PackagePath</code> <code>github.com/user/project/path/to/pkg</code> <code>PackagePathRelative</code> <code>path/to/pkg</code> <code>PackageName</code> <code>pkgName</code> <code>SourceFile</code> <code>./path/to/pkg/db.go</code> <p>Output</p> <p>Mock file will be generated at:</p> Text Only<pre><code>./path/to/pkg/mock_MyDatabase.go\n</code></pre> <p>The mock file will look like:</p> Go<pre><code>package pkgName\n\nimport mock \"github.com/stretchr/testify/mock\"\n\ntype MockMyDatabase struct {\n  mock.Mock\n}\n</code></pre>"},{"location":"configuration/#templated-strings","title":"Templated Strings","text":"<p>mockery configuration makes use of the Go templating system. </p>"},{"location":"configuration/#variables","title":"Variables","text":"<p>Note</p> <p>Templated variables are only available when using the <code>packages</code> config feature.</p> <p>Variables that are marked as being templated are capable of using mockery-provided template parameters.</p> name description ConfigDir The directory path of the config file used. This is used to allow generation of mocks in a directory relative to the <code>.mockery.yaml</code> file, e.g. external interfaces. InterfaceDir The directory path of the original interface being mocked. This can be used as <code>dir: \"{{.InterfaceDir}}\"</code> to place your mocks adjacent to the original interface. This should not be used for external interfaces. InterfaceDirRelative The directory path of the original interface being mocked, relative to the current working directory. If the path cannot be made relative to the current working directory, this variable will be set equal to <code>PackagePath</code> InterfaceFile The file path of the original interface being mocked. NOTE: This option will only write one mock implementation to the output file. If multiple mocks are defined in your original file, only one mock will be written to the output. InterfaceName The name of the original interface being mocked InterfaceNameCamel Converts a string <code>interface_name</code> to <code>InterfaceName</code>. DEPRECATED: use <code>{{ .InterfaceName | camelcase }}</code> instead InterfaceNameLowerCamel Converts <code>InterfaceName</code> to <code>interfaceName</code> . DEPRECATED: use <code>{{ .InterfaceName | camelcase | firstLower }}</code> instead InterfaceNameSnake Converts <code>InterfaceName</code> to <code>interface_name</code> . DEPRECATED: use <code>{{ .InterfaceName | snakecase }}</code> instead InterfaceNameLower Converts <code>InterfaceName</code> to <code>interfacename</code> . DEPRECATED: use <code>{{ .InterfaceName | lower }}</code> instead Mock A string that is <code>Mock</code> if the interface is exported, or <code>mock</code> if it is not exported. Useful when setting the name of your mock to something like: <code>mockname: \"{{.Mock}}{{.InterfaceName}}\"</code> This way, the mock name will retain the exported-ness of the original interface. MockName The name of the mock that will be generated. Note that this is simply the <code>mockname</code> configuration variable PackageName The name of the package from the original interface PackagePath The fully qualified package path of the original interface"},{"location":"configuration/#functions","title":"Functions","text":"<p>Note</p> <p>Templated functions are only available when using the <code>packages</code> config feature.</p> <p>Template functions allow you to inspect and manipulate template variables.</p> <p>All template functions are calling native Go functions under the hood, so signatures and return values matches the Go functions you are probably already familiar with.</p> <p>To learn more about the templating syntax, please see the Go <code>text/template</code> documentation</p> <ul> <li><code>contains</code> string substr</li> <li><code>hasPrefix</code> string prefix</li> <li><code>hasSuffix</code> string suffix</li> <li><code>join</code> elems sep</li> <li><code>replace</code> string old new n</li> <li><code>replaceAll</code> string old new</li> <li><code>split</code> string sep</li> <li><code>splitAfter</code> string sep</li> <li><code>splitAfterN</code> string sep n</li> <li><code>trim</code> string cutset</li> <li><code>trimLeft</code> string cutset</li> <li><code>trimPrefix</code> string prefix</li> <li><code>trimRight</code> string cutset</li> <li><code>trimSpace</code> string</li> <li><code>trimSuffix</code> string suffix</li> <li><code>lower</code> string</li> <li><code>upper</code> string</li> <li><code>camelcase</code> string</li> <li><code>snakecase</code> string</li> <li><code>kebabcase</code> string</li> <li><code>firstLower</code> string</li> <li><code>firstUpper</code> string</li> <li><code>matchString</code> pattern</li> <li><code>quoteMeta</code> string</li> <li><code>base</code> string</li> <li><code>clean</code> string</li> <li><code>dir</code> string</li> <li><code>expandEnv</code> string</li> <li><code>getenv</code> string</li> </ul>"},{"location":"configuration/#legacy-config-options","title":"Legacy config options","text":"legacy configuration options <p>The legacy config options will be removed in v3 and are deprecated (but supported) in v2.</p> name description <code>all</code> It's common for a big package to have a lot of interfaces, so mockery provides <code>all</code>. This option will tell mockery to scan all files under the directory named by <code>--dir</code> (\".\" by default) and generates mocks for any interfaces it finds. This option implies <code>recursive: True</code>. <code>boilerplate-file</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>case</code> mockery generates files using the casing of the original interface name.  This can be modified by specifying <code>case: underscore</code> to format the generated file name using underscore casing. <code>exclude</code> This parameter is a list of strings representing path prefixes that should be excluded from mock generation. <code>exported</code> Use <code>exported: True</code> to generate public mocks for private interfaces. <code>filename</code> Use the <code>filename</code> and <code>structname</code> to override the default generated file and struct name. These options are only compatible with non-regular expressions in <code>name</code>, where only one mock is generated. <code>inpackage-suffix</code> When <code>inpackage-suffix</code> is set to <code>True</code>, mock files are suffixed with <code>_mock</code> instead of being prefixed with <code>mock_</code> for InPackage mocks <code>inpackage</code> and <code>keeptree</code> For some complex repositories, there could be multiple interfaces with the same name but in different packages. In that case, <code>inpackage</code> allows generating the mocked interfaces directly in the package that it mocks. In the case you don't want to generate the mocks into the package but want to keep a similar structure, use the option <code>keeptree</code>. <code>name</code> The <code>name</code> option takes either the name or matching regular expression of the interface to generate mock(s) for. <code>output</code> mockery always generates files with the package <code>mocks</code> to keep things clean and simple. You can control which mocks directory is used by using <code>output</code>, which defaults to <code>./mocks</code>. <code>outpkg</code> Use <code>outpkg</code> to specify the package name of the generated mocks. <code>print</code> Use <code>print: True</code> to have the resulting code printed out instead of written to disk. <code>recursive</code> Use the <code>recursive</code> option to search subdirectories for the interface(s). This option is only compatible with <code>name</code>. The <code>all</code> option implies <code>recursive: True</code>. <code>replace-type source=destination</code> Replaces aliases, packages and/or types during generation. <code>testonly</code> Prepend every mock file with <code>_test.go</code>. This is useful in cases where you are generating mocks <code>inpackage</code> but don't want the mocks to be visible to code outside of tests. <code>with-expecter</code> Use <code>with-expecter: True</code> to generate <code>EXPECT()</code> methods for your mocks. This is the prefervar(--md-code-hl-number-color) way to setup your mocks."},{"location":"examples/","title":"Examples","text":"<p>Tip</p> <p>IDEs are really useful when interacting with mockery objects. All mockery objects embed the <code>github.com/stretchr/testify/mock.Mock</code> object so you have access to both methods provided by mockery, and from testify itself. IDE auto-completion will show you all methods available for your use.</p>"},{"location":"examples/#simple-case","title":"Simple case","text":"<p>Given this interface:</p> string.go<pre><code>package example_project\n\ntype Stringer interface {\n    String() string\n}\n</code></pre> <p>Create a mock for this interface by specifying it in your config. We can then create a test using this new mock object:</p> string_test.go<pre><code>package example_project\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Foo(s Stringer) string {\n    return s.String()\n}\n\nfunc TestString(t *testing.T) {\n    mockStringer := NewMockStringer(t)\n    mockStringer.EXPECT().String().Return(\"mockery\")\n    assert.Equal(t, \"mockery\", Foo(mockStringer))\n}\n</code></pre> <p>Note that in combination with using the mock's constructor and the <code>.EXPECT()</code> directives, your test will automatically fail if the expected call is not made. </p> Alternate way of specifying expectations <p>You can also use the <code>github.com/stretchr/testify/mock.Mock</code> object directly (instead of using the <code>.EXPECT()</code> methods, which provide type-safe-ish assertions).</p> string_test.go<pre><code>func TestString(t *testing.T) {\n    mockStringer := NewMockStringer(t)\n    mockStringer.On(\"String\").Return(\"mockery\")\n    assert.Equal(t, \"mockery\", Foo(mockStringer))\n}\n</code></pre> <p>We recommend always interacting with the assertions through <code>.EXPECT()</code> as mockery auto-generates methods that call out to <code>Mock.On()</code> themselves, providing you with some amount of compile-time safety. Consider if all your expectations for <code>String()</code> use the <code>Mock.On()</code> methods, and you decide to add an argument to <code>String()</code> to become <code>String(foo string)</code>. Now, your existing tests will only fail when you run them. If you had used <code>.EXPECT()</code> and regenerated your mocks after changing the function signature, your IDE, and the go compiler itself, would both tell you immediately that your expectations don't match the function signature. </p>"},{"location":"examples/#function-type-case","title":"Function type case","text":"<p>Bug</p> <p>Generating mocks for function types is likely not functioning in the <code>packages</code> config semantics. You'll likely need to revert to the legacy semantics as shown below.</p> <p>Given this is in <code>send.go</code></p> Go<pre><code>package test\n\ntype SendFunc func(data string) (int, error)\n</code></pre> <p>Run: <code>mockery --name=SendFunc</code> and the following will be output:</p> mock_SendFunc_test.go<pre><code>package mocks\n\nimport (\n    \"github.com/stretchr/testify/mock\"\n\n    testing \"testing\"\n)\n\ntype SendFunc struct {\n    mock.Mock\n}\n\nfunc (_m *SendFunc) Execute(data string) (int, error) {\n    ret := _m.Called(data)\n\n    var r0 int\n    if rf, ok := ret.Get(0).(func(string) int); ok {\n        r0 = rf(data)\n    } else {\n        r0 = ret.Get(0).(int)\n    }\n\n    var r1 error\n    if rf, ok := ret.Get(1).(func(string) error); ok {\n        r1 = rf(data)\n    } else {\n        r1 = ret.Error(1)\n    }\n\n    return r0, r1\n}\n\n// NewSendFunc creates a new instance of SendFunc. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\nfunc NewSendFunc(t testing.TB) *SendFunc {\n    mock := &amp;SendFunc{}\n    mock.Mock.Test(t)\n\n    t.Cleanup(func() { mock.AssertExpectations(t) })\n\n    return mock\n}\n</code></pre>"},{"location":"examples/#return-value-provider-functions","title":"Return Value Provider Functions","text":"<p>If your tests need access to the arguments to calculate the return values, set the return value to a function that takes the method's arguments as its own arguments and returns the return value. For example, given this interface:</p> Go<pre><code>package test\n\ntype Proxy interface {\n  passthrough(ctx context.Context, s string) string\n}\n</code></pre> <p>The argument can be passed through as the return value:</p> Go<pre><code>import . \"github.com/stretchr/testify/mock\"\n\nproxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\n    Return(func(ctx context.Context, s string) string {\n        return s\n    })\n</code></pre>"},{"location":"features/","title":"Features","text":""},{"location":"features/#replace-types","title":"Replace Types","text":"<p> v2.23.0</p> <p>The <code>replace-type</code> parameter allows adding a list of type replacements to be made in package and/or type names. This can help overcome issues like usage of type aliases that point to internal packages.</p> <p>The format of the parameter is:</p> <p><code>originalPackagePath.originalTypeName=newPackageName:newPackagePath.newTypeName</code></p> <p>For example:</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz=baz:github.com/vektra/mockery/v2/baz.Baz\n</code></pre> <p>This will replace any imported named <code>\"github.com/vektra/mockery/v2/baz/internal/foo\"</code> with <code>baz \"github.com/vektra/mockery/v2/baz\"</code>. The alias is defined with <code>:</code> before the package name. Also, the <code>InternalBaz</code> type that comes from this package will be renamed to <code>baz.Baz</code>.</p> <p>This next example fixes a common problem of type aliases that point to an internal package.</p> <p><code>cloud.google.com/go/pubsub.Message</code> is a type alias defined like this:</p> Go<pre><code>import (\n    ipubsub \"cloud.google.com/go/internal/pubsub\"\n)\n\ntype Message = ipubsub.Message\n</code></pre> <p>The Go parser that mockery uses doesn't provide a way to detect this alias and sends the application the package and type name of the type in the internal package, which will not work.</p> <p>We can use <code>replace-type</code> with only the package part to replace any import of <code>cloud.google.com/go/internal/pubsub</code> to <code>cloud.google.com/go/pubsub</code>. We don't need to change the alias or type name in this case, because they are <code>pubsub</code> and <code>Message</code> in both cases.</p> Bash<pre><code>mockery --replace-type cloud.google.com/go/internal/pubsub=cloud.google.com/go/pubsub\n</code></pre> <p>Original source:</p> Go<pre><code>import (\n    \"cloud.google.com/go/pubsub\"\n)\n\ntype Handler struct {\n    HandleMessage(m pubsub.Message) error\n}\n</code></pre> <p>Invalid mock generated without this parameter (points to an <code>internal</code> folder):</p> Go<pre><code>import (\n    mock \"github.com/stretchr/testify/mock\"\n\n    pubsub \"cloud.google.com/go/internal/pubsub\"\n)\n\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n    // ...\n    return nil\n}\n</code></pre> <p>Correct mock generated with this parameter.</p> Go<pre><code>import (\n    mock \"github.com/stretchr/testify/mock\"\n\n    pubsub \"cloud.google.com/go/pubsub\"\n)\n\nfunc (_m *Handler) HandleMessage(m pubsub.Message) error {\n    // ...\n    return nil\n}\n</code></pre> <p>Generic type constraints can also be replaced by targeting the changed parameter with the square bracket notation on the left-hand side.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz[T]=github.com/vektra/mockery/v2/baz.Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz[T baz.Baz] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n</code></pre> <p>If a type constraint needs to be removed and replaced with a type, target the constraint with square brackets and include a '-' in front to have it removed.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz[-T]=github.com/vektra/mockery/v2/baz.Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz struct{}\n\nfunc (*InternalBaz) Foo() baz.Baz {}\n</code></pre> <p>When replacing a generic constraint, you can replace the type with a pointer by adding a '*' before the output type name.</p> Bash<pre><code>mockery --replace-type github.com/vektra/mockery/v2/baz/internal/foo.InternalBaz[-T]=github.com/vektra/mockery/v2/baz.*Baz\n</code></pre> <p>For example:</p> Go<pre><code>type InternalBaz[T any] struct{}\n\nfunc (*InternalBaz[T]) Foo() T {}\n\n// Becomes\ntype InternalBaz struct{}\n\nfunc (*InternalBaz) Foo() *baz.Baz {}\n</code></pre>"},{"location":"features/#packages-configuration","title":"<code>packages</code> configuration","text":"<p> v2.21.0</p> <p>Info</p> <p>See the Migration Docs on how to migrate to this new feature.</p> <p>Mockery has a configuration parameter called <code>packages</code>. In this config section, you define the packages and the interfaces you want mocks generated for. The packages can be any arbitrary package, either your own project or anything within the Go ecosystem. You may provide package-level or interface-level overrides to the default config you provide.</p> <p>Usage of the <code>packages</code> config section is desirable for multiple reasons:</p> <ol> <li>Up to 5x increase in mock generation speed over the legacy method</li> <li>Granular control over interface generation, location, and file names</li> <li>Singular location for all config, instead of spread around by <code>//go:generate</code> statements</li> <li>Clean, easy to understand.</li> </ol>"},{"location":"features/#examples","title":"Examples","text":"<p>Here is an example configuration set:</p> YAML<pre><code>with-expecter: True\npackages:\n  github.com/vektra/mockery/v2/pkg: # (1)!\n    interfaces:\n      TypesPackage:\n      RequesterVariadic:\n        config: # (2)!\n          with-expecter: False \n        configs:\n          - mockname: MockRequesterVariadicOneArgument\n            unroll-variadic: False\n          - mockname: MockRequesterVariadic\n  io:\n    config:\n      all: True # (3)!\n    interfaces:\n      Writer:\n        config:\n          with-expecter: False # (4)!\n</code></pre> <ol> <li>For this package, we provide no package-level config (which means we inherit the defaults at the top-level). Since our default of <code>all:</code> is <code>False</code>, mockery will only generate the interfaces we specify. We tell it which interface to generate by using the <code>interfaces</code> section and specifying an empty map, one for each interface.</li> <li>There might be cases where you want multiple mocks generated from the same interface. To do this, you can define a default <code>config</code> section for the interface, and further <code>configs</code> (plural) section, one for each mock. You must specify a <code>mockname</code> for the mocks in this section to differentiate them.</li> <li>This is telling mockery to generate all interfaces in the <code>io</code> package.</li> <li>We can provide interface-specific overrides to the generation config.</li> </ol>"},{"location":"features/#templated-variables","title":"Templated variables","text":"<p>Note</p> <p>Templated variables are only available when using the <code>packages</code> config feature.</p> <p>Included with this feature is the ability to use templated strings for various configuration options. This is useful to define where your mocks are placed and how to name them. You can view the template variables available in the Configuration section of the docs.</p>"},{"location":"features/#recursive-package-discovery","title":"Recursive package discovery","text":"<p> v2.25.0</p> <p>When <code>recursive: true</code> is set on a particular package:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      with-expecter: true\n</code></pre> <p>mockery will dynamically discover all sub-packages within the specified package. This is done by calling <code>packages.Load</code> on the specified package, which induces Go to download the package from the internet (or simply your local project). Mockery then recursively discovers all sub-directories from the root package that also contain <code>.go</code> files and injects the respective package path into the config map as if you had specified them manually. As an example, your in-memory config map may end up looking like this:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      with-expecter: true\n  github.com/user/project/subpkg1:\n    config:\n      recursive: true\n      with-expecter: true\n  github.com/user/project/subpkg2:\n    config:\n      recursive: true\n      with-expecter: true\n</code></pre> <p>You can use the <code>showconfig</code> command to see the config mockery injects. The output of <code>showconfig</code> theoretically could be copy-pasted into your YAML file as it is semantically equivalent.</p> <p>mockery will not recurse into submodules, i.e. any subdirectory that contains a go.mod file. You must specify the submodule as a separate line item in the config if you would like mocks generated for it as well.</p> performance characteristics <p>The performance when using <code>recursive: true</code> may be worse than manually specifying all packages statically in the YAML file. This is because of the fact that mockery has to recursively walk the filesystem path that contains the package in question. It may unnecessarily walk down unrelated paths (for example, a Python virtual environment that is in the same path as your package). For this reason, it is recommended not to use <code>recursive: true</code> if it can be avoided.</p>"},{"location":"features/#regex-matching","title":"Regex matching","text":"<p>You can filter matched interfaces using the <code>include-regex</code> option. To generate mocks only for interfaces ending in <code>Client</code> we can use the following configuration:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      include-regex: \".*Client\"\n</code></pre> <p>To further refine matched interfaces, you can also use <code>exclude-regex</code>. If an interface matches both <code>include-regex</code> and <code>exclude-regex</code> then it will not be generated. For example, to generate all interfaces except those ending in <code>Func</code>:</p> YAML<pre><code>packages:\n  github.com/user/project:\n    config:\n      recursive: true\n      include-regex: \".*\"\n      exclude-regex: \".*Func\"\n</code></pre> <p>You can only use <code>exclude-regex</code> with <code>include-regex</code>. If set by itself, <code>exclude-regex</code> has no effect.</p> all: true <p>Using <code>all: true</code> will override <code>include-regex</code> (and <code>exclude-regex</code>) and issue a warning.</p>"},{"location":"features/#mock-constructors","title":"Mock Constructors","text":"<p> v2.11.0</p> <p>All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits.</p> <p>Previously something like this would need to be done: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>Instead, you may simply use the constructor: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically</p> <ul> <li>The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method.</li> <li>The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</li> </ul>"},{"location":"features/#expecter-structs","title":"Expecter Structs","text":"<p> v2.10.0 \u00b7 <code>with-expecter: True</code></p> <p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre></p> <p>You can use the expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\n</code></pre></p> <p>A <code>RunAndReturn</code> method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call.</p> Go<pre><code>requesterMock.EXPECT().\n    Get(mock.Anything).\n    RunAndReturn(func(path string) (string, error) { \n        fmt.Println(path, \"was called\")\n        return (\"result for \" + path), nil\n    })\n</code></pre> <p>Note</p> <p>Note that the types of the arguments on the <code>EXPECT</code> methods are <code>interface{}</code>, not the actual type of your interface. The reason for this is that you may want to pass <code>mock.Any</code> as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.</p>"},{"location":"features/#return-value-providers","title":"Return Value Providers","text":"<p> v2.20.0</p> <p>Return Value Providers can be used one of two ways. You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to <code>Return</code>, or you may pass multiple values to <code>Return</code> (one for each return parameter of the mocked function.)  If you are using the second form, for each of the return values of the mocked function, <code>Return</code> needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of <code>passthrough</code> in the above example was instead <code>(string, error)</code> in the interface, <code>Return</code> would also need a second function argument to define the error value:</p> Go<pre><code>type Proxy interface {\npassthrough(ctx context.Context, s string) (string, error)\n}\n</code></pre> <p>First form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) (string, error) {\n        return s, nil\n    }\n)\n</code></pre> <p>Second form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) string {\n        return s\n    },\n    func(ctx context.Context, s string) error {\n        return nil\n    },\n)\n</code></pre>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#github-release-recommended","title":"GitHub Release recommended","text":"<p>Visit the releases page to download one of the pre-built binaries for your platform.</p>"},{"location":"installation/#go-install","title":"go install","text":"<p>Supported, but not recommended: see wiki page and related discussions.</p> <p>Warning</p> <p>Do not use <code>@latest</code> as this will pull from the latest, potentially untagged, commit on master.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>Use the Docker image</p> Text Only<pre><code>docker pull vektra/mockery\n</code></pre> <p>Generate all the mocks for your project:</p> Text Only<pre><code>docker run -v \"$PWD\":/src -w /src vektra/mockery --all\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>Install through brew</p> Text Only<pre><code>brew install mockery\nbrew upgrade mockery\n</code></pre>"},{"location":"migrating_to_packages/","title":"Migrating To Packages","text":"<p>The packages feature is a new configuration scheme that aims to simplify and improve a lot of legacy behavior. This will be the only way to generate mocks in v3. These docs outline general principles for migrating to the new scheme.</p>"},{"location":"migrating_to_packages/#background","title":"Background","text":"<p>mockery was built during the pre-module era of Golang. Much of its codebase and configuration syntax was designed around file-based operations. This model became highly inefficient once Golang migrated to module-based packages. The old configuration semantics also proved limiting -- many users introduced and requested feature additions to mockery to support esoteric use-cases. This proved to be a huge maintenance burden that existed solely because the configuration model could not flexibly describe all the situations users wanted. The <code>packages</code> semantics provides us a few highly desirable traits:</p> <ol> <li>Orders of magnitude performance increase, due to calling <code>packages.Load</code> once or twice for an entire project, versus once per file in the legacy semantics.</li> <li>Hierarchical configuration model that allows interface-specific config to be inherited from package-level config, which is inherited from defaults.</li> <li>Single configuration file that describes the entirety of mockery's behavior, instead of spread out by <code>//go:generate</code> statements.</li> <li>Extensive and flexible usage of a Golang string templating environment that allows users to dynamically specify parameter values.</li> </ol>"},{"location":"migrating_to_packages/#configuration-changes","title":"Configuration Changes","text":"<p>The existence of the <code>packages:</code> map in your configuration acts as a feature flag that enables the feature.</p> <p>The configuration parameters used in <code>packages</code> should be considered to have no relation to their meanings in the legacy scheme. It is recommended to wipe out all previous configuration and command-line parameters previously used.</p> <p>The configuration docs show the parameters that are available for use in the <code>packages</code> scheme. You should only use the parameters shown in this section. Mockery will not prevent you from using the legacy parameter set, but doing so will result in undefined behavior.</p> <p>All of the parameters in the config section can be specified at the top level of the config file, which serves as the default values. The <code>packages</code> config section defines package-specific config. See some examples here.</p>"},{"location":"migrating_to_packages/#examples","title":"Examples","text":""},{"location":"migrating_to_packages/#separate-mocks-directory","title":"Separate <code>mocks/</code> directory","text":"<p>Take for example a configuration where you are specifying <code>all: true</code> at the top of your repo, and you're placing your mocks in a separate <code>mocks/</code> directory, mirroring the directory structure of your original repo.</p> YAML<pre><code>testonly: False\nwith-expecter: True\nkeeptree: True\nall: True\n</code></pre> <p>The equivalent config for <code>packages</code> looks like this:</p> YAML<pre><code>with-expecter: True\ndir: mocks/{{ replaceAll .InterfaceDirRelative \"internal\" \"internal_\" }} #(1)!\nmockname: \"{{.InterfaceName}}\"\noutpkg: \"{{.PackageName}}\"\nfilename: \"{{.InterfaceName}}.go\"\nall: True\npackages:\n  github.com/org/repo:\n    config:\n      recursive: True\n</code></pre> <ol> <li>The use of <code>replaceAll</code> is a trick that is done to ensure mocks created for <code>internal</code> packages can be imported outside the mock directory. This retains the behavior of the legacy config.</li> </ol> <p>While the example config provided here is more verbose, that is because we're specifying many non-default values in order to retain strict equivalence for this example. It's recommended to refer to the configuration parameters to see the defaults provided.</p>"},{"location":"migrating_to_packages/#adjacent-to-interface","title":"Adjacent to interface","text":"<p>Another common pattern in the legacy config is to place mocks next to the file that defined the interface.</p> YAML<pre><code>with-expecter: True\ninpackage: True\nall: True\n</code></pre> <p>For example, the mock file would be laid out like:</p> Text Only<pre><code>./getter.go\n./mock_Getter.go\n</code></pre> <p>The equivalent config would look like:</p> YAML<pre><code>with-expecter: True\ninpackage: True\ndir: \"{{.InterfaceDir}}\"\nmockname: \"Mock{{.InterfaceName}}\"\noutpkg: \"{{.PackageName}}\"\nfilename: \"mock_{{.InterfaceName}}.go\"\nall: True\npackages:\n  github.com/org/repo:\n    config:\n      recursive: True\n</code></pre>"},{"location":"migrating_to_packages/#gogenerate-directives","title":"<code>//go:generate</code> directives","text":"<p>Previously, the recommended way of generating mocks was to call <code>mockery</code> once per interface using <code>//go:generate</code>. Generating interface-specific mocks this way is no longer supported. You may still use <code>//go:generate</code> to call mockery, however it will generate all interfaces defined in your config file. There currently exists no semantics to specify the generation of specific interfaces from the command line (not because we reject the idea, but because it was not seen as a requirement for the initial iteration of <code>packages</code>).</p>"},{"location":"migrating_to_packages/#behavior-changes","title":"Behavior Changes","text":"<p>The legacy behavior iterated over every <code>.go</code> file in your project, called <code>packages.Load</code> to parse the syntax tree, and generated mocks for every interface found in the file. The new behavior instead simply grabs the list of packages to load from the config file, or in the case of <code>recursive: True</code>, walks the file-system tree to discover the packages that exist (without actually parsing the files). Using this list, it calls <code>packages.Load</code> once with the list of packages that were discovered.</p>"},{"location":"migrating_to_packages/#filesystem-tree-layouts","title":"Filesystem Tree Layouts","text":"<p>The legacy config provided the <code>inpackage</code> parameter which, if <code>inpackage: True</code>, would place the mocks in the same package as your interfaces. Otherwise, it would place it in a separate directory.</p> <p>These two layouts are supported in the <code>packages</code> scheme. See the relevant docs here.</p>"},{"location":"notes/","title":"Frequently Asked Questions","text":""},{"location":"notes/#error-no-go-files-found-in-root-search-path","title":"error: <code>no go files found in root search path</code>","text":"<p>When using the <code>packages</code> feature, <code>recursive: true</code> and you have specified a package that contains no <code>*.go</code> files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata.</p> <p>The solution is to create a <code>.go</code> file in the package's path and add a <code>package [name]</code> directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata.</p> <p>Discussion</p>"},{"location":"notes/#internal-error-package-without-types-was-imported","title":"internal error: package without types was imported","text":"<p>https://github.com/vektra/mockery/issues/475</p> <p>This issue indicates that you have attempted to use package in your dependency tree (whether direct or indirect) that uses Go language semantics that your currently-running Go version does not support. The solution:</p> <ol> <li>Update to the latest go version</li> <li>Delete all cached packages with <code>go clean -modcache</code></li> <li>Reinstall mockery</li> </ol> <p>Additionally, this issue only happens when compiling mockery from source, such as with <code>go install</code>. Our docs recommend not to use <code>go install</code> as the success of your build depends on the compatibility of your Go version with the semantics in use. You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the <code>.tar.gz</code> binaries, or through <code>brew install</code>.</p>"},{"location":"notes/#multiple-expectations-with-identical-arguments","title":"Multiple Expectations With Identical Arguments","text":"<p>There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example, we might want to test this behavior:</p> Go<pre><code>// Return \"foo\" on the first call\ngetter := NewGetter()\nassert(t, \"foo\", getter.Get(\"key\"))\n\n// Return \"bar\" on the second call\nassert(t, \"bar\", getter.Get(\"key\"))\n</code></pre> <p>This can be done by using the <code>.Once()</code> method on the mock call expectation:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Once()\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Once()\n</code></pre> <p>Or you can identify an arbitrary number of times each value should be returned:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Times(4)\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Times(2)\n</code></pre> <p>Note that with proper Go support in your IDE, all the available methods are self-documented in autocompletion help contexts.</p>"},{"location":"notes/#variadic-arguments","title":"Variadic Arguments","text":"<p>Consider if we have a function <code>func Bar(message ...string) error</code>. A typical assertion might look like this:</p> Go<pre><code>func TestFoo(t *testing.T) {\n  m := NewMockFoo(t)\n  m.On(\"Bar\", \"hello\", \"world\").Return(nil)\n</code></pre> <p>We might also want to make an assertion that says \"any number of variadic arguments\":</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions:</p> <ol> <li>Any number of variadic arguments of any value</li> <li>A single variadic argument of any value</li> </ol> <p>This is fixed in #359 where you can provide <code>unroll-variadic: False</code> to get back to the old behavior. Thus, if you want to assert (1), you can then do:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>If you want to assert (2), you must set <code>unroll-variadic: True</code>. Then this assertion's intention will be modified to mean the second case:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>An upstream patch to <code>testify</code> is currently underway to allow passing <code>mock.Anything</code> directly to the variadic slice: https://github.com/stretchr/testify/pull/1348</p> <p>If this is merged, it would become possible to describe the above two cases respectively:</p> Go<pre><code>// case 1\nm.On(\"Bar\", mock.Anything).Return(nil)\n// case 2\nm.On(\"Bar\", []interface{}{mock.Anything}).Return(nil)\n</code></pre> <p>References:</p> <ul> <li>https://github.com/vektra/mockery/pull/359</li> <li>https://github.com/vektra/mockery/pull/123</li> <li>https://github.com/vektra/mockery/pull/550</li> <li>https://github.com/vektra/mockery/issues/541</li> </ul>"},{"location":"notes/#semantic-versioning","title":"Semantic Versioning","text":"<p>The versioning in this project applies only to the behavior of the mockery binary itself. This project explicitly does not promise a stable internal API, but rather a stable executable. The versioning applies to the following:</p> <ol> <li>CLI arguments.</li> <li>Parsing of Go code. New features in the Go language will be supported in a backwards-compatible manner, except during major version bumps.</li> <li>Behavior of mock objects. Mock objects can be considered to be part of the public API.</li> <li>Behavior of mockery given a set of arguments.</li> </ol> <p>What the version does not track:</p> <ol> <li>The interfaces, objects, methods etc. in the vektra/mockery package.</li> <li>Compatibility of <code>go get</code>-ing mockery with new or old versions of Go.</li> </ol>"},{"location":"notes/#mocking-interfaces-in-main","title":"Mocking interfaces in <code>main</code>","text":"<p>When your interfaces are in the main package, you should supply the <code>--inpackage</code> flag. This will generate mocks in the same package as the target code, avoiding import issues.</p>"},{"location":"notes/#mockery-fails-to-run-when-mockery_version-environment-variable-is-set","title":"mockery fails to run when <code>MOCKERY_VERSION</code> environment variable is set","text":"<p>This issue was first highlighted in this GitHub issue.</p> <p>mockery uses the viper package for configuration mapping and parsing. Viper is set to automatically search for all config variables specified in its config struct. One of the config variables is named <code>version</code>, which gets mapped to an environment variable called <code>MOCKERY_VERSION</code>. If you set this environment variable, mockery attempts to parse it into the <code>version</code> bool config.</p> <p>This is an adverse effect of how our config parsing is set up. The solution is to rename your environment variable to something other than <code>MOCKERY_VERSION</code>.</p>"},{"location":"running/","title":"Running","text":"<p>If your <code>.mockery.yaml</code> file has been populated with the packages and interfaces you want mocked, mockery can be run with no arguments. Take for example how the mockery project itself is configured:</p> YAML<pre><code>quiet: False\nkeeptree: True\ndisable-version-string: True\nwith-expecter: True\nmockname: \"{{.InterfaceName}}\"\nfilename: \"{{.MockName}}.go\"\noutpkg: mocks\npackages:\n  github.com/vektra/mockery/v2/pkg:\n    interfaces:\n      TypesPackage:\n# Lots more config...\n</code></pre> <p>From anywhere within your repo, you can simply call <code>mockery</code> once, and it will find your config either by respecting the <code>config</code> path you gave it, or by searching upwards from the current working directory.</p> Bash<pre><code>mockery\n08 Jul 23 01:40 EDT INF Starting mockery dry-run=false version=v2.31.0\n08 Jul 23 01:40 EDT INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.31.0\n</code></pre> <p>Command line arguments</p> <p>It is valid to specify arguments from the command line. The configuration precedence is specified in the Configuration docs.</p>"}]}