// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package test

import (
	"io"
	"sync"
)

// Ensure, that RequesterVariadicMoq does implement RequesterVariadic.
// If this is not the case, regenerate this file with moq.
var _ RequesterVariadic = &RequesterVariadicMoq{}

// RequesterVariadicMoq is a mock implementation of RequesterVariadic.
//
//	func TestSomethingThatUsesRequesterVariadic(t *testing.T) {
//
//		// make and configure a mocked RequesterVariadic
//		mockedRequesterVariadic := &RequesterVariadicMoq{
//			GetFunc: func(values ...string) bool {
//				panic("mock out the Get method")
//			},
//			MultiWriteToFileFunc: func(filename string, w ...io.Writer) string {
//				panic("mock out the MultiWriteToFile method")
//			},
//			OneInterfaceFunc: func(a ...interface{}) bool {
//				panic("mock out the OneInterface method")
//			},
//			SprintfFunc: func(format string, a ...interface{}) string {
//				panic("mock out the Sprintf method")
//			},
//		}
//
//		// use mockedRequesterVariadic in code that requires RequesterVariadic
//		// and then make assertions.
//
//	}
type RequesterVariadicMoq struct {
	// GetFunc mocks the Get method.
	GetFunc func(values ...string) bool

	// MultiWriteToFileFunc mocks the MultiWriteToFile method.
	MultiWriteToFileFunc func(filename string, w ...io.Writer) string

	// OneInterfaceFunc mocks the OneInterface method.
	OneInterfaceFunc func(a ...interface{}) bool

	// SprintfFunc mocks the Sprintf method.
	SprintfFunc func(format string, a ...interface{}) string

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Values is the values argument value.
			Values []string
		}
		// MultiWriteToFile holds details about calls to the MultiWriteToFile method.
		MultiWriteToFile []struct {
			// Filename is the filename argument value.
			Filename string
			// W is the w argument value.
			W []io.Writer
		}
		// OneInterface holds details about calls to the OneInterface method.
		OneInterface []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Sprintf holds details about calls to the Sprintf method.
		Sprintf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
	}
	lockGet              sync.RWMutex
	lockMultiWriteToFile sync.RWMutex
	lockOneInterface     sync.RWMutex
	lockSprintf          sync.RWMutex
}

// Get calls GetFunc.
func (mock *RequesterVariadicMoq) Get(values ...string) bool {
	if mock.GetFunc == nil {
		panic("RequesterVariadicMoq.GetFunc: method is nil but RequesterVariadic.Get was just called")
	}
	callInfo := struct {
		Values []string
	}{
		Values: values,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(values...)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterVariadic.GetCalls())
func (mock *RequesterVariadicMoq) GetCalls() []struct {
	Values []string
} {
	var calls []struct {
		Values []string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *RequesterVariadicMoq) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// MultiWriteToFile calls MultiWriteToFileFunc.
func (mock *RequesterVariadicMoq) MultiWriteToFile(filename string, w ...io.Writer) string {
	if mock.MultiWriteToFileFunc == nil {
		panic("RequesterVariadicMoq.MultiWriteToFileFunc: method is nil but RequesterVariadic.MultiWriteToFile was just called")
	}
	callInfo := struct {
		Filename string
		W        []io.Writer
	}{
		Filename: filename,
		W:        w,
	}
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = append(mock.calls.MultiWriteToFile, callInfo)
	mock.lockMultiWriteToFile.Unlock()
	return mock.MultiWriteToFileFunc(filename, w...)
}

// MultiWriteToFileCalls gets all the calls that were made to MultiWriteToFile.
// Check the length with:
//
//	len(mockedRequesterVariadic.MultiWriteToFileCalls())
func (mock *RequesterVariadicMoq) MultiWriteToFileCalls() []struct {
	Filename string
	W        []io.Writer
} {
	var calls []struct {
		Filename string
		W        []io.Writer
	}
	mock.lockMultiWriteToFile.RLock()
	calls = mock.calls.MultiWriteToFile
	mock.lockMultiWriteToFile.RUnlock()
	return calls
}

// ResetMultiWriteToFileCalls reset all the calls that were made to MultiWriteToFile.
func (mock *RequesterVariadicMoq) ResetMultiWriteToFileCalls() {
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()
}

// OneInterface calls OneInterfaceFunc.
func (mock *RequesterVariadicMoq) OneInterface(a ...interface{}) bool {
	if mock.OneInterfaceFunc == nil {
		panic("RequesterVariadicMoq.OneInterfaceFunc: method is nil but RequesterVariadic.OneInterface was just called")
	}
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = append(mock.calls.OneInterface, callInfo)
	mock.lockOneInterface.Unlock()
	return mock.OneInterfaceFunc(a...)
}

// OneInterfaceCalls gets all the calls that were made to OneInterface.
// Check the length with:
//
//	len(mockedRequesterVariadic.OneInterfaceCalls())
func (mock *RequesterVariadicMoq) OneInterfaceCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockOneInterface.RLock()
	calls = mock.calls.OneInterface
	mock.lockOneInterface.RUnlock()
	return calls
}

// ResetOneInterfaceCalls reset all the calls that were made to OneInterface.
func (mock *RequesterVariadicMoq) ResetOneInterfaceCalls() {
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()
}

// Sprintf calls SprintfFunc.
func (mock *RequesterVariadicMoq) Sprintf(format string, a ...interface{}) string {
	if mock.SprintfFunc == nil {
		panic("RequesterVariadicMoq.SprintfFunc: method is nil but RequesterVariadic.Sprintf was just called")
	}
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = append(mock.calls.Sprintf, callInfo)
	mock.lockSprintf.Unlock()
	return mock.SprintfFunc(format, a...)
}

// SprintfCalls gets all the calls that were made to Sprintf.
// Check the length with:
//
//	len(mockedRequesterVariadic.SprintfCalls())
func (mock *RequesterVariadicMoq) SprintfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockSprintf.RLock()
	calls = mock.calls.Sprintf
	mock.lockSprintf.RUnlock()
	return calls
}

// ResetSprintfCalls reset all the calls that were made to Sprintf.
func (mock *RequesterVariadicMoq) ResetSprintfCalls() {
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *RequesterVariadicMoq) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()

	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()

	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}
