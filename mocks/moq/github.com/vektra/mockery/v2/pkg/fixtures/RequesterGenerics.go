// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package testfoo

import (
	"io"
	"sync"

	test "github.com/vektra/mockery/v2/pkg/fixtures"
	"github.com/vektra/mockery/v2/pkg/fixtures/constraints"
)

// Ensure, that RequesterGenerics does implement test.RequesterGenerics.
// If this is not the case, regenerate this file with moq.
var _ test.RequesterGenerics[any, comparable, int, test.GetInt, io.Writer, test.GetGeneric[TSigned], int, int] = &RequesterGenerics[any, comparable, int, test.GetInt, io.Writer, test.GetGeneric[TSigned], int, int]{}

// RequesterGenerics is a mock implementation of test.RequesterGenerics.
//
//	func TestSomethingThatUsesRequesterGenerics(t *testing.T) {
//
//		// make and configure a mocked test.RequesterGenerics
//		mockedRequesterGenerics := &RequesterGenerics{
//			GenericAnonymousStructsFunc: func(val struct{Type1 TExternalIntf}) struct{Type2 test.GenericType[string, test.EmbeddedGet[int]]} {
//				panic("mock out the GenericAnonymousStructs method")
//			},
//			GenericArgumentsFunc: func(v1 TAny, v2 TComparable) (TSigned, TIntf) {
//				panic("mock out the GenericArguments method")
//			},
//			GenericStructsFunc: func(genericType test.GenericType[TAny, TIntf]) test.GenericType[TSigned, TIntf] {
//				panic("mock out the GenericStructs method")
//			},
//		}
//
//		// use mockedRequesterGenerics in code that requires test.RequesterGenerics
//		// and then make assertions.
//
//	}
type RequesterGenerics[TAny any, TComparable comparable, TSigned constraints.Signed, TIntf test.GetInt, TExternalIntf io.Writer, TGenIntf test.GetGeneric[TSigned], TInlineType interface{ ~int | ~uint }, TInlineTypeGeneric interface {
	~int | GenericType[int, GetInt]
	comparable
}] struct {
	// GenericAnonymousStructsFunc mocks the GenericAnonymousStructs method.
	GenericAnonymousStructsFunc func(val struct{ Type1 TExternalIntf }) struct {
		Type2 test.GenericType[string, test.EmbeddedGet[int]]
	}

	// GenericArgumentsFunc mocks the GenericArguments method.
	GenericArgumentsFunc func(v1 TAny, v2 TComparable) (TSigned, TIntf)

	// GenericStructsFunc mocks the GenericStructs method.
	GenericStructsFunc func(genericType test.GenericType[TAny, TIntf]) test.GenericType[TSigned, TIntf]

	// calls tracks calls to the methods.
	calls struct {
		// GenericAnonymousStructs holds details about calls to the GenericAnonymousStructs method.
		GenericAnonymousStructs []struct {
			// Val is the val argument value.
			Val struct{ Type1 TExternalIntf }
		}
		// GenericArguments holds details about calls to the GenericArguments method.
		GenericArguments []struct {
			// V1 is the v1 argument value.
			V1 TAny
			// V2 is the v2 argument value.
			V2 TComparable
		}
		// GenericStructs holds details about calls to the GenericStructs method.
		GenericStructs []struct {
			// GenericType is the genericType argument value.
			GenericType test.GenericType[TAny, TIntf]
		}
	}
	lockGenericAnonymousStructs sync.RWMutex
	lockGenericArguments        sync.RWMutex
	lockGenericStructs          sync.RWMutex
}

// GenericAnonymousStructs calls GenericAnonymousStructsFunc.
func (mock *RequesterGenerics[TAny, TComparable, TSigned, TIntf, TExternalIntf, TGenIntf, TInlineType, TInlineTypeGeneric]) GenericAnonymousStructs(val struct{ Type1 TExternalIntf }) struct {
	Type2 test.GenericType[string, test.EmbeddedGet[int]]
} {
	if mock.GenericAnonymousStructsFunc == nil {
		panic("RequesterGenerics.GenericAnonymousStructsFunc: method is nil but RequesterGenerics.GenericAnonymousStructs was just called")
	}
	callInfo := struct {
		Val struct{ Type1 TExternalIntf }
	}{
		Val: val,
	}
	mock.lockGenericAnonymousStructs.Lock()
	mock.calls.GenericAnonymousStructs = append(mock.calls.GenericAnonymousStructs, callInfo)
	mock.lockGenericAnonymousStructs.Unlock()
	return mock.GenericAnonymousStructsFunc(val)
}

// GenericAnonymousStructsCalls gets all the calls that were made to GenericAnonymousStructs.
// Check the length with:
//
//	len(mockedRequesterGenerics.GenericAnonymousStructsCalls())
func (mock *RequesterGenerics[TAny, TComparable, TSigned, TIntf, TExternalIntf, TGenIntf, TInlineType, TInlineTypeGeneric]) GenericAnonymousStructsCalls() []struct {
	Val struct{ Type1 TExternalIntf }
} {
	var calls []struct {
		Val struct{ Type1 TExternalIntf }
	}
	mock.lockGenericAnonymousStructs.RLock()
	calls = mock.calls.GenericAnonymousStructs
	mock.lockGenericAnonymousStructs.RUnlock()
	return calls
}

// GenericArguments calls GenericArgumentsFunc.
func (mock *RequesterGenerics[TAny, TComparable, TSigned, TIntf, TExternalIntf, TGenIntf, TInlineType, TInlineTypeGeneric]) GenericArguments(v1 TAny, v2 TComparable) (TSigned, TIntf) {
	if mock.GenericArgumentsFunc == nil {
		panic("RequesterGenerics.GenericArgumentsFunc: method is nil but RequesterGenerics.GenericArguments was just called")
	}
	callInfo := struct {
		V1 TAny
		V2 TComparable
	}{
		V1: v1,
		V2: v2,
	}
	mock.lockGenericArguments.Lock()
	mock.calls.GenericArguments = append(mock.calls.GenericArguments, callInfo)
	mock.lockGenericArguments.Unlock()
	return mock.GenericArgumentsFunc(v1, v2)
}

// GenericArgumentsCalls gets all the calls that were made to GenericArguments.
// Check the length with:
//
//	len(mockedRequesterGenerics.GenericArgumentsCalls())
func (mock *RequesterGenerics[TAny, TComparable, TSigned, TIntf, TExternalIntf, TGenIntf, TInlineType, TInlineTypeGeneric]) GenericArgumentsCalls() []struct {
	V1 TAny
	V2 TComparable
} {
	var calls []struct {
		V1 TAny
		V2 TComparable
	}
	mock.lockGenericArguments.RLock()
	calls = mock.calls.GenericArguments
	mock.lockGenericArguments.RUnlock()
	return calls
}

// GenericStructs calls GenericStructsFunc.
func (mock *RequesterGenerics[TAny, TComparable, TSigned, TIntf, TExternalIntf, TGenIntf, TInlineType, TInlineTypeGeneric]) GenericStructs(genericType test.GenericType[TAny, TIntf]) test.GenericType[TSigned, TIntf] {
	if mock.GenericStructsFunc == nil {
		panic("RequesterGenerics.GenericStructsFunc: method is nil but RequesterGenerics.GenericStructs was just called")
	}
	callInfo := struct {
		GenericType test.GenericType[TAny, TIntf]
	}{
		GenericType: genericType,
	}
	mock.lockGenericStructs.Lock()
	mock.calls.GenericStructs = append(mock.calls.GenericStructs, callInfo)
	mock.lockGenericStructs.Unlock()
	return mock.GenericStructsFunc(genericType)
}

// GenericStructsCalls gets all the calls that were made to GenericStructs.
// Check the length with:
//
//	len(mockedRequesterGenerics.GenericStructsCalls())
func (mock *RequesterGenerics[TAny, TComparable, TSigned, TIntf, TExternalIntf, TGenIntf, TInlineType, TInlineTypeGeneric]) GenericStructsCalls() []struct {
	GenericType test.GenericType[TAny, TIntf]
} {
	var calls []struct {
		GenericType test.GenericType[TAny, TIntf]
	}
	mock.lockGenericStructs.RLock()
	calls = mock.calls.GenericStructs
	mock.lockGenericStructs.RUnlock()
	return calls
}
