// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package testfoo

import (
	"sync"

	test "github.com/vektra/mockery/v2/pkg/fixtures"
)

// Ensure, that ConsulLock does implement test.ConsulLock.
// If this is not the case, regenerate this file with moq.
var _ test.ConsulLock = &ConsulLock{}

// ConsulLock is a mock implementation of test.ConsulLock.
//
//	func TestSomethingThatUsesConsulLock(t *testing.T) {
//
//		// make and configure a mocked test.ConsulLock
//		mockedConsulLock := &ConsulLock{
//			LockFunc: func(valCh <-chan struct{}) (<-chan struct{}, error) {
//				panic("mock out the Lock method")
//			},
//			UnlockFunc: func() error {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedConsulLock in code that requires test.ConsulLock
//		// and then make assertions.
//
//	}
type ConsulLock struct {
	// LockFunc mocks the Lock method.
	LockFunc func(valCh <-chan struct{}) (<-chan struct{}, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// ValCh is the valCh argument value.
			ValCh <-chan struct{}
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
		}
	}
	lockLock   sync.RWMutex
	lockUnlock sync.RWMutex
}

// Lock calls LockFunc.
func (mock *ConsulLock) Lock(valCh <-chan struct{}) (<-chan struct{}, error) {
	if mock.LockFunc == nil {
		panic("ConsulLock.LockFunc: method is nil but ConsulLock.Lock was just called")
	}
	callInfo := struct {
		ValCh <-chan struct{}
	}{
		ValCh: valCh,
	}
	mock.lockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	mock.lockLock.Unlock()
	return mock.LockFunc(valCh)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//
//	len(mockedConsulLock.LockCalls())
func (mock *ConsulLock) LockCalls() []struct {
	ValCh <-chan struct{}
} {
	var calls []struct {
		ValCh <-chan struct{}
	}
	mock.lockLock.RLock()
	calls = mock.calls.Lock
	mock.lockLock.RUnlock()
	return calls
}

// Unlock calls UnlockFunc.
func (mock *ConsulLock) Unlock() error {
	if mock.UnlockFunc == nil {
		panic("ConsulLock.UnlockFunc: method is nil but ConsulLock.Unlock was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc()
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedConsulLock.UnlockCalls())
func (mock *ConsulLock) UnlockCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}
