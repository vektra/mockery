// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery

package testfoo

import (
	"sync"

	test "github.com/vektra/mockery/v2/pkg/fixtures"
)

// Ensure, that StructWithTag does implement test.StructWithTag.
// If this is not the case, regenerate this file with moq.
var _ test.StructWithTag = &StructWithTag{}

// StructWithTag is a mock implementation of test.StructWithTag.
//
//	func TestSomethingThatUsesStructWithTag(t *testing.T) {
//
//		// make and configure a mocked test.StructWithTag
//		mockedStructWithTag := &StructWithTag{
//			MethodAFunc: func(v *struct{FieldA int "json:\"field_a\""; FieldB int "json:\"field_b\" xml:\"field_b\""}) *struct{FieldC int "json:\"field_c\""; FieldD int "json:\"field_d\" xml:\"field_d\""} {
//				panic("mock out the MethodA method")
//			},
//		}
//
//		// use mockedStructWithTag in code that requires test.StructWithTag
//		// and then make assertions.
//
//	}
type StructWithTag struct {
	// MethodAFunc mocks the MethodA method.
	MethodAFunc func(v *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}) *struct {
		FieldC int "json:\"field_c\""
		FieldD int "json:\"field_d\" xml:\"field_d\""
	}

	// calls tracks calls to the methods.
	calls struct {
		// MethodA holds details about calls to the MethodA method.
		MethodA []struct {
			// V is the v argument value.
			V *struct {
				FieldA int "json:\"field_a\""
				FieldB int "json:\"field_b\" xml:\"field_b\""
			}
		}
	}
	lockMethodA sync.RWMutex
}

// MethodA calls MethodAFunc.
func (mock *StructWithTag) MethodA(v *struct {
	FieldA int "json:\"field_a\""
	FieldB int "json:\"field_b\" xml:\"field_b\""
}) *struct {
	FieldC int "json:\"field_c\""
	FieldD int "json:\"field_d\" xml:\"field_d\""
} {
	if mock.MethodAFunc == nil {
		panic("StructWithTag.MethodAFunc: method is nil but StructWithTag.MethodA was just called")
	}
	callInfo := struct {
		V *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}{
		V: v,
	}
	mock.lockMethodA.Lock()
	mock.calls.MethodA = append(mock.calls.MethodA, callInfo)
	mock.lockMethodA.Unlock()
	return mock.MethodAFunc(v)
}

// MethodACalls gets all the calls that were made to MethodA.
// Check the length with:
//
//	len(mockedStructWithTag.MethodACalls())
func (mock *StructWithTag) MethodACalls() []struct {
	V *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}
} {
	var calls []struct {
		V *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}
	mock.lockMethodA.RLock()
	calls = mock.calls.MethodA
	mock.lockMethodA.RUnlock()
	return calls
}
