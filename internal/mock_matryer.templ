// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer
{{- if (index .TemplateData "boilerplate-file") }}
{{ index .TemplateData "boilerplate-file" | readFile }}
{{- end }}
{{- if (index .TemplateData "mock-build-tags") }}

//go:build {{ index .TemplateData "mock-build-tags" }}
{{- end }}

package {{.PkgName}}

import (
{{- range .Imports}}
	{{ .ImportStatement }}
{{- end}}
{{- if .Interfaces.ImplementsSomeMethod }}
    "sync"
{{- end }}
    "fmt"
)

{{range $i, $mock := .Interfaces -}}

{{- if not (index $mock.TemplateData "skip-ensure") -}}
// Ensure that {{.StructName}} does implement {{$.SrcPkgQualifier}}{{.Name}}.
// If this is not the case, regenerate this file with moq.
var _ {{$.SrcPkgQualifier}}{{.Name -}}
	{{- if .TypeParams }}[
		{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}
		]
	{{- end }} = &{{.StructName}}
	 {{- if .TypeParams }}[
		{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end -}}
			{{if $param.Constraint}}{{$param.Constraint.String}}{{else}}{{$param.TypeString}}{{end}}
		{{- end -}}
		]
	{{- end -}}
{}
{{- end}}

// {{.StructName}} is a mock implementation of {{$.SrcPkgQualifier}}{{.Name}}.
//
//	func TestSomethingThatUses{{.Name}}(t *testing.T) {
//
//		// make and configure a mocked {{$.SrcPkgQualifier}}{{.Name}}
//		mocked{{.Name}} := &{{.StructName}}{
			{{- range .Methods}}
//			{{.Name}}Func: func({{.ArgList}}) {{.ReturnArgTypeList}} {
//				panic("mock out the {{.Name}} method")
//			},
			{{- end}}
//		}
//
//		// use mocked{{.Name}} in code that requires {{$.SrcPkgQualifier}}{{.Name}}
//		// and then make assertions.
//
//	}
type {{.StructName}}
{{- if .TypeParams -}}
	[{{- range $index, $param := .TypeParams}}
			{{- if $index}}, {{end}}{{$param.Name | exported}} {{$param.TypeString}}
	{{- end -}}]
{{- end }} struct {
{{- range .Methods}}
	// {{.Name}}Func mocks the {{.Name}} method.
	{{.Name}}Func func({{.ArgList}}) {{.ReturnArgTypeList}}
{{end}}
	// calls tracks calls to the methods.
	calls struct {
{{- range .Methods}}
		// {{.Name}} holds details about calls to the {{.Name}} method.
		{{.Name}} []struct {
			{{- range .Params}}
			// {{.Name | exported}} is the {{.Name}} argument value.
			{{.Name | exported}} {{.TypeString}}
			{{- end}}
		}
{{- end}}
	}
{{- range $i, $method := .Methods}}
	lock{{ $method.Name }} {{ $.Imports.SyncPkgQualifier }}.RWMutex
{{- end}}
}
{{range .Methods}}
// {{.Name}} calls {{.Name}}Func.
func (mock *{{$mock.StructName}}{{ $mock.TypeInstantiation }}) {{.Name}}({{.ArgList}}) {{.ReturnArgTypeList}} {
{{- if not (index $mock.TemplateData "stub-impl") }}
	if mock.{{.Name}}Func == nil {
		panic("{{$mock.StructName}}.{{.Name}}Func: method is nil but {{$mock.Name}}.{{.Name}} was just called")
	}
{{- end}}
	callInfo := struct {
		{{- range .Params}}
		{{.Name | exported}} {{.TypeString}}
		{{- end}}
	}{
		{{- range .Params}}
		{{.Name | exported}}: {{.Name}},
		{{- end}}
	}
	mock.lock{{.Name}}.Lock()
	mock.calls.{{.Name}} = append(mock.calls.{{.Name}}, callInfo)
	mock.lock{{.Name}}.Unlock()
{{- if .Returns}}
	{{- if (index $mock.TemplateData "stub-impl") }}
	if mock.{{.Name}}Func == nil {
		var (
		{{- range .Returns}}
			{{.Name}} {{.TypeString}}
		{{- end}}
		)
		return {{.ReturnArgNameList}}
	}
	{{- end}}
	return mock.{{.Name}}Func({{.ArgCallList}})
{{- else}}
	{{- if (index $mock.TemplateData "stub-impl") }}
	if mock.{{.Name}}Func == nil {
		return
	}
	{{- end}}
	mock.{{.Name}}Func({{.ArgCallList}})
{{- end}}
}

// {{.Name}}Calls gets all the calls that were made to {{.Name}}.
// Check the length with:
//
//	len(mocked{{$mock.Name}}.{{.Name}}Calls())
func (mock *{{$mock.StructName}}{{ $mock.TypeInstantiation }}) {{.Name}}Calls() []struct {
		{{- range .Params}}
		{{.Name | exported}} {{.TypeString}}
		{{- end}}
	} {
	var calls []struct {
		{{- range .Params}}
		{{.Name | exported}} {{.TypeString}}
		{{- end}}
	}
	mock.lock{{.Name}}.RLock()
	calls = mock.calls.{{.Name}}
	mock.lock{{.Name}}.RUnlock()
	return calls
}
{{- if index $.TemplateData "with-resets" }}
// Reset{{.Name}}Calls reset all the calls that were made to {{.Name}}.
func (mock *{{$mock.StructName}}{{ $mock.TypeInstantiation }}) Reset{{.Name}}Calls() {
	mock.lock{{.Name}}.Lock()
	mock.calls.{{.Name}} = nil
	mock.lock{{.Name}}.Unlock()
}
{{end}}
{{end -}}
{{- if index $.TemplateData "with-resets" }}
// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *{{$mock.StructName}}{{ $mock.TypeInstantiation }}) ResetCalls() {
	{{- range .Methods}}
	mock.lock{{.Name}}.Lock()
	mock.calls.{{.Name}} = nil
	mock.lock{{.Name}}.Unlock()
	{{end -}}
}
{{end -}}
{{end -}}