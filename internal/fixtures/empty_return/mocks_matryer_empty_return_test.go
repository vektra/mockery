// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer
// TEST MOCKERY BOILERPLATE

package empty_return

import (
	"sync"
)

// Ensure that StubMatyerEmptyReturn does implement EmptyReturn.
// If this is not the case, regenerate this file with moq.
var _ EmptyReturn = &StubMatyerEmptyReturn{}

// StubMatyerEmptyReturn is a mock implementation of EmptyReturn.
//
//	func TestSomethingThatUsesEmptyReturn(t *testing.T) {
//
//		// make and configure a mocked EmptyReturn
//		mockedEmptyReturn := &StubMatyerEmptyReturn{
//			NoArgsFunc: func()  {
//				panic("mock out the NoArgs method")
//			},
//			WithArgsFunc: func(a int, b string)  {
//				panic("mock out the WithArgs method")
//			},
//		}
//
//		// use mockedEmptyReturn in code that requires EmptyReturn
//		// and then make assertions.
//
//	}
type StubMatyerEmptyReturn struct {
	// NoArgsFunc mocks the NoArgs method.
	NoArgsFunc func()

	// WithArgsFunc mocks the WithArgs method.
	WithArgsFunc func(a int, b string)

	// calls tracks calls to the methods.
	calls struct {
		// NoArgs holds details about calls to the NoArgs method.
		NoArgs []struct {
		}
		// WithArgs holds details about calls to the WithArgs method.
		WithArgs []struct {
			// A is the a argument value.
			A int
			// B is the b argument value.
			B string
		}
	}
	lockNoArgs   sync.RWMutex
	lockWithArgs sync.RWMutex
}

// NoArgs calls NoArgsFunc.
func (mock *StubMatyerEmptyReturn) NoArgs() {
	callInfo := struct {
	}{}
	mock.lockNoArgs.Lock()
	mock.calls.NoArgs = append(mock.calls.NoArgs, callInfo)
	mock.lockNoArgs.Unlock()
	if mock.NoArgsFunc == nil {
		return
	}
	mock.NoArgsFunc()
}

// NoArgsCalls gets all the calls that were made to NoArgs.
// Check the length with:
//
//	len(mockedEmptyReturn.NoArgsCalls())
func (mock *StubMatyerEmptyReturn) NoArgsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNoArgs.RLock()
	calls = mock.calls.NoArgs
	mock.lockNoArgs.RUnlock()
	return calls
}

// ResetNoArgsCalls reset all the calls that were made to NoArgs.
func (mock *StubMatyerEmptyReturn) ResetNoArgsCalls() {
	mock.lockNoArgs.Lock()
	mock.calls.NoArgs = nil
	mock.lockNoArgs.Unlock()
}

// WithArgs calls WithArgsFunc.
func (mock *StubMatyerEmptyReturn) WithArgs(a int, b string) {
	callInfo := struct {
		A int
		B string
	}{
		A: a,
		B: b,
	}
	mock.lockWithArgs.Lock()
	mock.calls.WithArgs = append(mock.calls.WithArgs, callInfo)
	mock.lockWithArgs.Unlock()
	if mock.WithArgsFunc == nil {
		return
	}
	mock.WithArgsFunc(a, b)
}

// WithArgsCalls gets all the calls that were made to WithArgs.
// Check the length with:
//
//	len(mockedEmptyReturn.WithArgsCalls())
func (mock *StubMatyerEmptyReturn) WithArgsCalls() []struct {
	A int
	B string
} {
	var calls []struct {
		A int
		B string
	}
	mock.lockWithArgs.RLock()
	calls = mock.calls.WithArgs
	mock.lockWithArgs.RUnlock()
	return calls
}

// ResetWithArgsCalls reset all the calls that were made to WithArgs.
func (mock *StubMatyerEmptyReturn) ResetWithArgsCalls() {
	mock.lockWithArgs.Lock()
	mock.calls.WithArgs = nil
	mock.lockWithArgs.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *StubMatyerEmptyReturn) ResetCalls() {
	mock.lockNoArgs.Lock()
	mock.calls.NoArgs = nil
	mock.lockNoArgs.Unlock()

	mock.lockWithArgs.Lock()
	mock.calls.WithArgs = nil
	mock.lockWithArgs.Unlock()
}
