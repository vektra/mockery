// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify
// TEST MOCKERY BOILERPLATE

package test

import (
	"io"

	mock "github.com/stretchr/testify/mock"
)

// NewMockReader creates a new instance of MockReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReader {
	mock := &MockReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReader is an autogenerated mock type for the Reader type
type MockReader struct {
	mock.Mock
}

type MockReader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReader) EXPECT() *MockReader_Expecter {
	return &MockReader_Expecter{mock: &_m.Mock}
}

// Read provides a mock function for the type MockReader
func (_mock *MockReader) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReader_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReader_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReader_Expecter) Read(p interface{}) *MockReader_Read_Call {
	return &MockReader_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReader_Read_Call) Run(run func(p []byte)) *MockReader_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReader_Read_Call) Return(n int, err error) *MockReader_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReader_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReader_Read_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWriter creates a new instance of MockWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWriter {
	mock := &MockWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWriter is an autogenerated mock type for the Writer type
type MockWriter struct {
	mock.Mock
}

type MockWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWriter) EXPECT() *MockWriter_Expecter {
	return &MockWriter_Expecter{mock: &_m.Mock}
}

// Write provides a mock function for the type MockWriter
func (_mock *MockWriter) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriter_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockWriter_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *MockWriter_Expecter) Write(p interface{}) *MockWriter_Write_Call {
	return &MockWriter_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockWriter_Write_Call) Run(run func(p []byte)) *MockWriter_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockWriter_Write_Call) Return(n int, err error) *MockWriter_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriter_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockWriter_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCloser creates a new instance of MockCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCloser {
	mock := &MockCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCloser is an autogenerated mock type for the Closer type
type MockCloser struct {
	mock.Mock
}

type MockCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCloser) EXPECT() *MockCloser_Expecter {
	return &MockCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockCloser
func (_mock *MockCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockCloser_Expecter) Close() *MockCloser_Close_Call {
	return &MockCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockCloser_Close_Call) Run(run func()) *MockCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCloser_Close_Call) Return(err error) *MockCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockCloser_Close_Call) RunAndReturn(run func() error) *MockCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSeeker creates a new instance of MockSeeker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSeeker(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSeeker {
	mock := &MockSeeker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSeeker is an autogenerated mock type for the Seeker type
type MockSeeker struct {
	mock.Mock
}

type MockSeeker_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSeeker) EXPECT() *MockSeeker_Expecter {
	return &MockSeeker_Expecter{mock: &_m.Mock}
}

// Seek provides a mock function for the type MockSeeker
func (_mock *MockSeeker) Seek(offset int64, whence int) (int64, error) {
	ret := _mock.Called(offset, whence)

	if len(ret) == 0 {
		panic("no return value specified for Seek")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int) (int64, error)); ok {
		return returnFunc(offset, whence)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = returnFunc(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = returnFunc(offset, whence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSeeker_Seek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seek'
type MockSeeker_Seek_Call struct {
	*mock.Call
}

// Seek is a helper method to define mock.On call
//   - offset
//   - whence
func (_e *MockSeeker_Expecter) Seek(offset interface{}, whence interface{}) *MockSeeker_Seek_Call {
	return &MockSeeker_Seek_Call{Call: _e.mock.On("Seek", offset, whence)}
}

func (_c *MockSeeker_Seek_Call) Run(run func(offset int64, whence int)) *MockSeeker_Seek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int))
	})
	return _c
}

func (_c *MockSeeker_Seek_Call) Return(n int64, err error) *MockSeeker_Seek_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockSeeker_Seek_Call) RunAndReturn(run func(offset int64, whence int) (int64, error)) *MockSeeker_Seek_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadWriter creates a new instance of MockReadWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadWriter {
	mock := &MockReadWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadWriter is an autogenerated mock type for the ReadWriter type
type MockReadWriter struct {
	mock.Mock
}

type MockReadWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadWriter) EXPECT() *MockReadWriter_Expecter {
	return &MockReadWriter_Expecter{mock: &_m.Mock}
}

// Read provides a mock function for the type MockReadWriter
func (_mock *MockReadWriter) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriter_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReadWriter_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReadWriter_Expecter) Read(p interface{}) *MockReadWriter_Read_Call {
	return &MockReadWriter_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReadWriter_Read_Call) Run(run func(p []byte)) *MockReadWriter_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadWriter_Read_Call) Return(n int, err error) *MockReadWriter_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriter_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadWriter_Read_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockReadWriter
func (_mock *MockReadWriter) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriter_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockReadWriter_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *MockReadWriter_Expecter) Write(p interface{}) *MockReadWriter_Write_Call {
	return &MockReadWriter_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockReadWriter_Write_Call) Run(run func(p []byte)) *MockReadWriter_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadWriter_Write_Call) Return(n int, err error) *MockReadWriter_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriter_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadWriter_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadCloser creates a new instance of MockReadCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadCloser {
	mock := &MockReadCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadCloser is an autogenerated mock type for the ReadCloser type
type MockReadCloser struct {
	mock.Mock
}

type MockReadCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadCloser) EXPECT() *MockReadCloser_Expecter {
	return &MockReadCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockReadCloser
func (_mock *MockReadCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockReadCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockReadCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockReadCloser_Expecter) Close() *MockReadCloser_Close_Call {
	return &MockReadCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockReadCloser_Close_Call) Run(run func()) *MockReadCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReadCloser_Close_Call) Return(err error) *MockReadCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockReadCloser_Close_Call) RunAndReturn(run func() error) *MockReadCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function for the type MockReadCloser
func (_mock *MockReadCloser) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadCloser_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReadCloser_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReadCloser_Expecter) Read(p interface{}) *MockReadCloser_Read_Call {
	return &MockReadCloser_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReadCloser_Read_Call) Run(run func(p []byte)) *MockReadCloser_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadCloser_Read_Call) Return(n int, err error) *MockReadCloser_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadCloser_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadCloser_Read_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWriteCloser creates a new instance of MockWriteCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWriteCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWriteCloser {
	mock := &MockWriteCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWriteCloser is an autogenerated mock type for the WriteCloser type
type MockWriteCloser struct {
	mock.Mock
}

type MockWriteCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWriteCloser) EXPECT() *MockWriteCloser_Expecter {
	return &MockWriteCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockWriteCloser
func (_mock *MockWriteCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockWriteCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockWriteCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockWriteCloser_Expecter) Close() *MockWriteCloser_Close_Call {
	return &MockWriteCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockWriteCloser_Close_Call) Run(run func()) *MockWriteCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockWriteCloser_Close_Call) Return(err error) *MockWriteCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockWriteCloser_Close_Call) RunAndReturn(run func() error) *MockWriteCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockWriteCloser
func (_mock *MockWriteCloser) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriteCloser_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockWriteCloser_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *MockWriteCloser_Expecter) Write(p interface{}) *MockWriteCloser_Write_Call {
	return &MockWriteCloser_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockWriteCloser_Write_Call) Run(run func(p []byte)) *MockWriteCloser_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockWriteCloser_Write_Call) Return(n int, err error) *MockWriteCloser_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriteCloser_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockWriteCloser_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadWriteCloser creates a new instance of MockReadWriteCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadWriteCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadWriteCloser {
	mock := &MockReadWriteCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadWriteCloser is an autogenerated mock type for the ReadWriteCloser type
type MockReadWriteCloser struct {
	mock.Mock
}

type MockReadWriteCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadWriteCloser) EXPECT() *MockReadWriteCloser_Expecter {
	return &MockReadWriteCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockReadWriteCloser
func (_mock *MockReadWriteCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockReadWriteCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockReadWriteCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockReadWriteCloser_Expecter) Close() *MockReadWriteCloser_Close_Call {
	return &MockReadWriteCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockReadWriteCloser_Close_Call) Run(run func()) *MockReadWriteCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReadWriteCloser_Close_Call) Return(err error) *MockReadWriteCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockReadWriteCloser_Close_Call) RunAndReturn(run func() error) *MockReadWriteCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function for the type MockReadWriteCloser
func (_mock *MockReadWriteCloser) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriteCloser_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReadWriteCloser_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReadWriteCloser_Expecter) Read(p interface{}) *MockReadWriteCloser_Read_Call {
	return &MockReadWriteCloser_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReadWriteCloser_Read_Call) Run(run func(p []byte)) *MockReadWriteCloser_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadWriteCloser_Read_Call) Return(n int, err error) *MockReadWriteCloser_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriteCloser_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadWriteCloser_Read_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockReadWriteCloser
func (_mock *MockReadWriteCloser) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriteCloser_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockReadWriteCloser_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *MockReadWriteCloser_Expecter) Write(p interface{}) *MockReadWriteCloser_Write_Call {
	return &MockReadWriteCloser_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockReadWriteCloser_Write_Call) Run(run func(p []byte)) *MockReadWriteCloser_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadWriteCloser_Write_Call) Return(n int, err error) *MockReadWriteCloser_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriteCloser_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadWriteCloser_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadSeeker creates a new instance of MockReadSeeker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadSeeker(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadSeeker {
	mock := &MockReadSeeker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadSeeker is an autogenerated mock type for the ReadSeeker type
type MockReadSeeker struct {
	mock.Mock
}

type MockReadSeeker_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadSeeker) EXPECT() *MockReadSeeker_Expecter {
	return &MockReadSeeker_Expecter{mock: &_m.Mock}
}

// Read provides a mock function for the type MockReadSeeker
func (_mock *MockReadSeeker) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadSeeker_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReadSeeker_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReadSeeker_Expecter) Read(p interface{}) *MockReadSeeker_Read_Call {
	return &MockReadSeeker_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReadSeeker_Read_Call) Run(run func(p []byte)) *MockReadSeeker_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadSeeker_Read_Call) Return(n int, err error) *MockReadSeeker_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadSeeker_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadSeeker_Read_Call {
	_c.Call.Return(run)
	return _c
}

// Seek provides a mock function for the type MockReadSeeker
func (_mock *MockReadSeeker) Seek(offset int64, whence int) (int64, error) {
	ret := _mock.Called(offset, whence)

	if len(ret) == 0 {
		panic("no return value specified for Seek")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int) (int64, error)); ok {
		return returnFunc(offset, whence)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = returnFunc(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = returnFunc(offset, whence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadSeeker_Seek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seek'
type MockReadSeeker_Seek_Call struct {
	*mock.Call
}

// Seek is a helper method to define mock.On call
//   - offset
//   - whence
func (_e *MockReadSeeker_Expecter) Seek(offset interface{}, whence interface{}) *MockReadSeeker_Seek_Call {
	return &MockReadSeeker_Seek_Call{Call: _e.mock.On("Seek", offset, whence)}
}

func (_c *MockReadSeeker_Seek_Call) Run(run func(offset int64, whence int)) *MockReadSeeker_Seek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int))
	})
	return _c
}

func (_c *MockReadSeeker_Seek_Call) Return(n int64, err error) *MockReadSeeker_Seek_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadSeeker_Seek_Call) RunAndReturn(run func(offset int64, whence int) (int64, error)) *MockReadSeeker_Seek_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadSeekCloser creates a new instance of MockReadSeekCloser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadSeekCloser(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadSeekCloser {
	mock := &MockReadSeekCloser{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadSeekCloser is an autogenerated mock type for the ReadSeekCloser type
type MockReadSeekCloser struct {
	mock.Mock
}

type MockReadSeekCloser_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadSeekCloser) EXPECT() *MockReadSeekCloser_Expecter {
	return &MockReadSeekCloser_Expecter{mock: &_m.Mock}
}

// Close provides a mock function for the type MockReadSeekCloser
func (_mock *MockReadSeekCloser) Close() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockReadSeekCloser_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockReadSeekCloser_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
func (_e *MockReadSeekCloser_Expecter) Close() *MockReadSeekCloser_Close_Call {
	return &MockReadSeekCloser_Close_Call{Call: _e.mock.On("Close")}
}

func (_c *MockReadSeekCloser_Close_Call) Run(run func()) *MockReadSeekCloser_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockReadSeekCloser_Close_Call) Return(err error) *MockReadSeekCloser_Close_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockReadSeekCloser_Close_Call) RunAndReturn(run func() error) *MockReadSeekCloser_Close_Call {
	_c.Call.Return(run)
	return _c
}

// Read provides a mock function for the type MockReadSeekCloser
func (_mock *MockReadSeekCloser) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadSeekCloser_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReadSeekCloser_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReadSeekCloser_Expecter) Read(p interface{}) *MockReadSeekCloser_Read_Call {
	return &MockReadSeekCloser_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReadSeekCloser_Read_Call) Run(run func(p []byte)) *MockReadSeekCloser_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadSeekCloser_Read_Call) Return(n int, err error) *MockReadSeekCloser_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadSeekCloser_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadSeekCloser_Read_Call {
	_c.Call.Return(run)
	return _c
}

// Seek provides a mock function for the type MockReadSeekCloser
func (_mock *MockReadSeekCloser) Seek(offset int64, whence int) (int64, error) {
	ret := _mock.Called(offset, whence)

	if len(ret) == 0 {
		panic("no return value specified for Seek")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int) (int64, error)); ok {
		return returnFunc(offset, whence)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = returnFunc(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = returnFunc(offset, whence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadSeekCloser_Seek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seek'
type MockReadSeekCloser_Seek_Call struct {
	*mock.Call
}

// Seek is a helper method to define mock.On call
//   - offset
//   - whence
func (_e *MockReadSeekCloser_Expecter) Seek(offset interface{}, whence interface{}) *MockReadSeekCloser_Seek_Call {
	return &MockReadSeekCloser_Seek_Call{Call: _e.mock.On("Seek", offset, whence)}
}

func (_c *MockReadSeekCloser_Seek_Call) Run(run func(offset int64, whence int)) *MockReadSeekCloser_Seek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int))
	})
	return _c
}

func (_c *MockReadSeekCloser_Seek_Call) Return(n int64, err error) *MockReadSeekCloser_Seek_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadSeekCloser_Seek_Call) RunAndReturn(run func(offset int64, whence int) (int64, error)) *MockReadSeekCloser_Seek_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWriteSeeker creates a new instance of MockWriteSeeker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWriteSeeker(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWriteSeeker {
	mock := &MockWriteSeeker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWriteSeeker is an autogenerated mock type for the WriteSeeker type
type MockWriteSeeker struct {
	mock.Mock
}

type MockWriteSeeker_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWriteSeeker) EXPECT() *MockWriteSeeker_Expecter {
	return &MockWriteSeeker_Expecter{mock: &_m.Mock}
}

// Seek provides a mock function for the type MockWriteSeeker
func (_mock *MockWriteSeeker) Seek(offset int64, whence int) (int64, error) {
	ret := _mock.Called(offset, whence)

	if len(ret) == 0 {
		panic("no return value specified for Seek")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int) (int64, error)); ok {
		return returnFunc(offset, whence)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = returnFunc(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = returnFunc(offset, whence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriteSeeker_Seek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seek'
type MockWriteSeeker_Seek_Call struct {
	*mock.Call
}

// Seek is a helper method to define mock.On call
//   - offset
//   - whence
func (_e *MockWriteSeeker_Expecter) Seek(offset interface{}, whence interface{}) *MockWriteSeeker_Seek_Call {
	return &MockWriteSeeker_Seek_Call{Call: _e.mock.On("Seek", offset, whence)}
}

func (_c *MockWriteSeeker_Seek_Call) Run(run func(offset int64, whence int)) *MockWriteSeeker_Seek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int))
	})
	return _c
}

func (_c *MockWriteSeeker_Seek_Call) Return(n int64, err error) *MockWriteSeeker_Seek_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriteSeeker_Seek_Call) RunAndReturn(run func(offset int64, whence int) (int64, error)) *MockWriteSeeker_Seek_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockWriteSeeker
func (_mock *MockWriteSeeker) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriteSeeker_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockWriteSeeker_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *MockWriteSeeker_Expecter) Write(p interface{}) *MockWriteSeeker_Write_Call {
	return &MockWriteSeeker_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockWriteSeeker_Write_Call) Run(run func(p []byte)) *MockWriteSeeker_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockWriteSeeker_Write_Call) Return(n int, err error) *MockWriteSeeker_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriteSeeker_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockWriteSeeker_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReadWriteSeeker creates a new instance of MockReadWriteSeeker. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReadWriteSeeker(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReadWriteSeeker {
	mock := &MockReadWriteSeeker{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReadWriteSeeker is an autogenerated mock type for the ReadWriteSeeker type
type MockReadWriteSeeker struct {
	mock.Mock
}

type MockReadWriteSeeker_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReadWriteSeeker) EXPECT() *MockReadWriteSeeker_Expecter {
	return &MockReadWriteSeeker_Expecter{mock: &_m.Mock}
}

// Read provides a mock function for the type MockReadWriteSeeker
func (_mock *MockReadWriteSeeker) Read(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Read")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriteSeeker_Read_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Read'
type MockReadWriteSeeker_Read_Call struct {
	*mock.Call
}

// Read is a helper method to define mock.On call
//   - p
func (_e *MockReadWriteSeeker_Expecter) Read(p interface{}) *MockReadWriteSeeker_Read_Call {
	return &MockReadWriteSeeker_Read_Call{Call: _e.mock.On("Read", p)}
}

func (_c *MockReadWriteSeeker_Read_Call) Run(run func(p []byte)) *MockReadWriteSeeker_Read_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadWriteSeeker_Read_Call) Return(n int, err error) *MockReadWriteSeeker_Read_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriteSeeker_Read_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadWriteSeeker_Read_Call {
	_c.Call.Return(run)
	return _c
}

// Seek provides a mock function for the type MockReadWriteSeeker
func (_mock *MockReadWriteSeeker) Seek(offset int64, whence int) (int64, error) {
	ret := _mock.Called(offset, whence)

	if len(ret) == 0 {
		panic("no return value specified for Seek")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(int64, int) (int64, error)); ok {
		return returnFunc(offset, whence)
	}
	if returnFunc, ok := ret.Get(0).(func(int64, int) int64); ok {
		r0 = returnFunc(offset, whence)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(int64, int) error); ok {
		r1 = returnFunc(offset, whence)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriteSeeker_Seek_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Seek'
type MockReadWriteSeeker_Seek_Call struct {
	*mock.Call
}

// Seek is a helper method to define mock.On call
//   - offset
//   - whence
func (_e *MockReadWriteSeeker_Expecter) Seek(offset interface{}, whence interface{}) *MockReadWriteSeeker_Seek_Call {
	return &MockReadWriteSeeker_Seek_Call{Call: _e.mock.On("Seek", offset, whence)}
}

func (_c *MockReadWriteSeeker_Seek_Call) Run(run func(offset int64, whence int)) *MockReadWriteSeeker_Seek_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int64), args[1].(int))
	})
	return _c
}

func (_c *MockReadWriteSeeker_Seek_Call) Return(n int64, err error) *MockReadWriteSeeker_Seek_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriteSeeker_Seek_Call) RunAndReturn(run func(offset int64, whence int) (int64, error)) *MockReadWriteSeeker_Seek_Call {
	_c.Call.Return(run)
	return _c
}

// Write provides a mock function for the type MockReadWriteSeeker
func (_mock *MockReadWriteSeeker) Write(p []byte) (int, error) {
	ret := _mock.Called(p)

	if len(ret) == 0 {
		panic("no return value specified for Write")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte) (int, error)); ok {
		return returnFunc(p)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte) int); ok {
		r0 = returnFunc(p)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = returnFunc(p)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReadWriteSeeker_Write_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Write'
type MockReadWriteSeeker_Write_Call struct {
	*mock.Call
}

// Write is a helper method to define mock.On call
//   - p
func (_e *MockReadWriteSeeker_Expecter) Write(p interface{}) *MockReadWriteSeeker_Write_Call {
	return &MockReadWriteSeeker_Write_Call{Call: _e.mock.On("Write", p)}
}

func (_c *MockReadWriteSeeker_Write_Call) Run(run func(p []byte)) *MockReadWriteSeeker_Write_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte))
	})
	return _c
}

func (_c *MockReadWriteSeeker_Write_Call) Return(n int, err error) *MockReadWriteSeeker_Write_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReadWriteSeeker_Write_Call) RunAndReturn(run func(p []byte) (int, error)) *MockReadWriteSeeker_Write_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReaderFrom creates a new instance of MockReaderFrom. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReaderFrom(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReaderFrom {
	mock := &MockReaderFrom{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReaderFrom is an autogenerated mock type for the ReaderFrom type
type MockReaderFrom struct {
	mock.Mock
}

type MockReaderFrom_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReaderFrom) EXPECT() *MockReaderFrom_Expecter {
	return &MockReaderFrom_Expecter{mock: &_m.Mock}
}

// ReadFrom provides a mock function for the type MockReaderFrom
func (_mock *MockReaderFrom) ReadFrom(r io.Reader) (int64, error) {
	ret := _mock.Called(r)

	if len(ret) == 0 {
		panic("no return value specified for ReadFrom")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Reader) (int64, error)); ok {
		return returnFunc(r)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Reader) int64); ok {
		r0 = returnFunc(r)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Reader) error); ok {
		r1 = returnFunc(r)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReaderFrom_ReadFrom_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFrom'
type MockReaderFrom_ReadFrom_Call struct {
	*mock.Call
}

// ReadFrom is a helper method to define mock.On call
//   - r
func (_e *MockReaderFrom_Expecter) ReadFrom(r interface{}) *MockReaderFrom_ReadFrom_Call {
	return &MockReaderFrom_ReadFrom_Call{Call: _e.mock.On("ReadFrom", r)}
}

func (_c *MockReaderFrom_ReadFrom_Call) Run(run func(r io.Reader)) *MockReaderFrom_ReadFrom_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(io.Reader))
	})
	return _c
}

func (_c *MockReaderFrom_ReadFrom_Call) Return(n int64, err error) *MockReaderFrom_ReadFrom_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReaderFrom_ReadFrom_Call) RunAndReturn(run func(r io.Reader) (int64, error)) *MockReaderFrom_ReadFrom_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWriterTo creates a new instance of MockWriterTo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWriterTo(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWriterTo {
	mock := &MockWriterTo{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWriterTo is an autogenerated mock type for the WriterTo type
type MockWriterTo struct {
	mock.Mock
}

type MockWriterTo_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWriterTo) EXPECT() *MockWriterTo_Expecter {
	return &MockWriterTo_Expecter{mock: &_m.Mock}
}

// WriteTo provides a mock function for the type MockWriterTo
func (_mock *MockWriterTo) WriteTo(w io.Writer) (int64, error) {
	ret := _mock.Called(w)

	if len(ret) == 0 {
		panic("no return value specified for WriteTo")
	}

	var r0 int64
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(io.Writer) (int64, error)); ok {
		return returnFunc(w)
	}
	if returnFunc, ok := ret.Get(0).(func(io.Writer) int64); ok {
		r0 = returnFunc(w)
	} else {
		r0 = ret.Get(0).(int64)
	}
	if returnFunc, ok := ret.Get(1).(func(io.Writer) error); ok {
		r1 = returnFunc(w)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriterTo_WriteTo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteTo'
type MockWriterTo_WriteTo_Call struct {
	*mock.Call
}

// WriteTo is a helper method to define mock.On call
//   - w
func (_e *MockWriterTo_Expecter) WriteTo(w interface{}) *MockWriterTo_WriteTo_Call {
	return &MockWriterTo_WriteTo_Call{Call: _e.mock.On("WriteTo", w)}
}

func (_c *MockWriterTo_WriteTo_Call) Run(run func(w io.Writer)) *MockWriterTo_WriteTo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(io.Writer))
	})
	return _c
}

func (_c *MockWriterTo_WriteTo_Call) Return(n int64, err error) *MockWriterTo_WriteTo_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriterTo_WriteTo_Call) RunAndReturn(run func(w io.Writer) (int64, error)) *MockWriterTo_WriteTo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockReaderAt creates a new instance of MockReaderAt. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockReaderAt(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockReaderAt {
	mock := &MockReaderAt{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockReaderAt is an autogenerated mock type for the ReaderAt type
type MockReaderAt struct {
	mock.Mock
}

type MockReaderAt_Expecter struct {
	mock *mock.Mock
}

func (_m *MockReaderAt) EXPECT() *MockReaderAt_Expecter {
	return &MockReaderAt_Expecter{mock: &_m.Mock}
}

// ReadAt provides a mock function for the type MockReaderAt
func (_mock *MockReaderAt) ReadAt(p []byte, off int64) (int, error) {
	ret := _mock.Called(p, off)

	if len(ret) == 0 {
		panic("no return value specified for ReadAt")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, int64) (int, error)); ok {
		return returnFunc(p, off)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, int64) int); ok {
		r0 = returnFunc(p, off)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, int64) error); ok {
		r1 = returnFunc(p, off)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockReaderAt_ReadAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadAt'
type MockReaderAt_ReadAt_Call struct {
	*mock.Call
}

// ReadAt is a helper method to define mock.On call
//   - p
//   - off
func (_e *MockReaderAt_Expecter) ReadAt(p interface{}, off interface{}) *MockReaderAt_ReadAt_Call {
	return &MockReaderAt_ReadAt_Call{Call: _e.mock.On("ReadAt", p, off)}
}

func (_c *MockReaderAt_ReadAt_Call) Run(run func(p []byte, off int64)) *MockReaderAt_ReadAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(int64))
	})
	return _c
}

func (_c *MockReaderAt_ReadAt_Call) Return(n int, err error) *MockReaderAt_ReadAt_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockReaderAt_ReadAt_Call) RunAndReturn(run func(p []byte, off int64) (int, error)) *MockReaderAt_ReadAt_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockWriterAt creates a new instance of MockWriterAt. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockWriterAt(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockWriterAt {
	mock := &MockWriterAt{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockWriterAt is an autogenerated mock type for the WriterAt type
type MockWriterAt struct {
	mock.Mock
}

type MockWriterAt_Expecter struct {
	mock *mock.Mock
}

func (_m *MockWriterAt) EXPECT() *MockWriterAt_Expecter {
	return &MockWriterAt_Expecter{mock: &_m.Mock}
}

// WriteAt provides a mock function for the type MockWriterAt
func (_mock *MockWriterAt) WriteAt(p []byte, off int64) (int, error) {
	ret := _mock.Called(p, off)

	if len(ret) == 0 {
		panic("no return value specified for WriteAt")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func([]byte, int64) (int, error)); ok {
		return returnFunc(p, off)
	}
	if returnFunc, ok := ret.Get(0).(func([]byte, int64) int); ok {
		r0 = returnFunc(p, off)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func([]byte, int64) error); ok {
		r1 = returnFunc(p, off)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockWriterAt_WriteAt_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteAt'
type MockWriterAt_WriteAt_Call struct {
	*mock.Call
}

// WriteAt is a helper method to define mock.On call
//   - p
//   - off
func (_e *MockWriterAt_Expecter) WriteAt(p interface{}, off interface{}) *MockWriterAt_WriteAt_Call {
	return &MockWriterAt_WriteAt_Call{Call: _e.mock.On("WriteAt", p, off)}
}

func (_c *MockWriterAt_WriteAt_Call) Run(run func(p []byte, off int64)) *MockWriterAt_WriteAt_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]byte), args[1].(int64))
	})
	return _c
}

func (_c *MockWriterAt_WriteAt_Call) Return(n int, err error) *MockWriterAt_WriteAt_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockWriterAt_WriteAt_Call) RunAndReturn(run func(p []byte, off int64) (int, error)) *MockWriterAt_WriteAt_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockByteReader creates a new instance of MockByteReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockByteReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockByteReader {
	mock := &MockByteReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockByteReader is an autogenerated mock type for the ByteReader type
type MockByteReader struct {
	mock.Mock
}

type MockByteReader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockByteReader) EXPECT() *MockByteReader_Expecter {
	return &MockByteReader_Expecter{mock: &_m.Mock}
}

// ReadByte provides a mock function for the type MockByteReader
func (_mock *MockByteReader) ReadByte() (byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadByte")
	}

	var r0 byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() byte); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(byte)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockByteReader_ReadByte_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadByte'
type MockByteReader_ReadByte_Call struct {
	*mock.Call
}

// ReadByte is a helper method to define mock.On call
func (_e *MockByteReader_Expecter) ReadByte() *MockByteReader_ReadByte_Call {
	return &MockByteReader_ReadByte_Call{Call: _e.mock.On("ReadByte")}
}

func (_c *MockByteReader_ReadByte_Call) Run(run func()) *MockByteReader_ReadByte_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockByteReader_ReadByte_Call) Return(v byte, err error) *MockByteReader_ReadByte_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockByteReader_ReadByte_Call) RunAndReturn(run func() (byte, error)) *MockByteReader_ReadByte_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockByteScanner creates a new instance of MockByteScanner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockByteScanner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockByteScanner {
	mock := &MockByteScanner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockByteScanner is an autogenerated mock type for the ByteScanner type
type MockByteScanner struct {
	mock.Mock
}

type MockByteScanner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockByteScanner) EXPECT() *MockByteScanner_Expecter {
	return &MockByteScanner_Expecter{mock: &_m.Mock}
}

// ReadByte provides a mock function for the type MockByteScanner
func (_mock *MockByteScanner) ReadByte() (byte, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadByte")
	}

	var r0 byte
	var r1 error
	if returnFunc, ok := ret.Get(0).(func() (byte, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() byte); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(byte)
	}
	if returnFunc, ok := ret.Get(1).(func() error); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockByteScanner_ReadByte_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadByte'
type MockByteScanner_ReadByte_Call struct {
	*mock.Call
}

// ReadByte is a helper method to define mock.On call
func (_e *MockByteScanner_Expecter) ReadByte() *MockByteScanner_ReadByte_Call {
	return &MockByteScanner_ReadByte_Call{Call: _e.mock.On("ReadByte")}
}

func (_c *MockByteScanner_ReadByte_Call) Run(run func()) *MockByteScanner_ReadByte_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockByteScanner_ReadByte_Call) Return(v byte, err error) *MockByteScanner_ReadByte_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockByteScanner_ReadByte_Call) RunAndReturn(run func() (byte, error)) *MockByteScanner_ReadByte_Call {
	_c.Call.Return(run)
	return _c
}

// UnreadByte provides a mock function for the type MockByteScanner
func (_mock *MockByteScanner) UnreadByte() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for UnreadByte")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockByteScanner_UnreadByte_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnreadByte'
type MockByteScanner_UnreadByte_Call struct {
	*mock.Call
}

// UnreadByte is a helper method to define mock.On call
func (_e *MockByteScanner_Expecter) UnreadByte() *MockByteScanner_UnreadByte_Call {
	return &MockByteScanner_UnreadByte_Call{Call: _e.mock.On("UnreadByte")}
}

func (_c *MockByteScanner_UnreadByte_Call) Run(run func()) *MockByteScanner_UnreadByte_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockByteScanner_UnreadByte_Call) Return(err error) *MockByteScanner_UnreadByte_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockByteScanner_UnreadByte_Call) RunAndReturn(run func() error) *MockByteScanner_UnreadByte_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockByteWriter creates a new instance of MockByteWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockByteWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockByteWriter {
	mock := &MockByteWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockByteWriter is an autogenerated mock type for the ByteWriter type
type MockByteWriter struct {
	mock.Mock
}

type MockByteWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockByteWriter) EXPECT() *MockByteWriter_Expecter {
	return &MockByteWriter_Expecter{mock: &_m.Mock}
}

// WriteByte provides a mock function for the type MockByteWriter
func (_mock *MockByteWriter) WriteByte(c byte) error {
	ret := _mock.Called(c)

	if len(ret) == 0 {
		panic("no return value specified for WriteByte")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(byte) error); ok {
		r0 = returnFunc(c)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockByteWriter_WriteByte_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteByte'
type MockByteWriter_WriteByte_Call struct {
	*mock.Call
}

// WriteByte is a helper method to define mock.On call
//   - c
func (_e *MockByteWriter_Expecter) WriteByte(c interface{}) *MockByteWriter_WriteByte_Call {
	return &MockByteWriter_WriteByte_Call{Call: _e.mock.On("WriteByte", c)}
}

func (_c *MockByteWriter_WriteByte_Call) Run(run func(c byte)) *MockByteWriter_WriteByte_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(byte))
	})
	return _c
}

func (_c *MockByteWriter_WriteByte_Call) Return(err error) *MockByteWriter_WriteByte_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockByteWriter_WriteByte_Call) RunAndReturn(run func(c byte) error) *MockByteWriter_WriteByte_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRuneReader creates a new instance of MockRuneReader. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRuneReader(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRuneReader {
	mock := &MockRuneReader{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRuneReader is an autogenerated mock type for the RuneReader type
type MockRuneReader struct {
	mock.Mock
}

type MockRuneReader_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRuneReader) EXPECT() *MockRuneReader_Expecter {
	return &MockRuneReader_Expecter{mock: &_m.Mock}
}

// ReadRune provides a mock function for the type MockRuneReader
func (_mock *MockRuneReader) ReadRune() (rune, int, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadRune")
	}

	var r0 rune
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (rune, int, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() rune); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(rune)
	}
	if returnFunc, ok := ret.Get(1).(func() int); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockRuneReader_ReadRune_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadRune'
type MockRuneReader_ReadRune_Call struct {
	*mock.Call
}

// ReadRune is a helper method to define mock.On call
func (_e *MockRuneReader_Expecter) ReadRune() *MockRuneReader_ReadRune_Call {
	return &MockRuneReader_ReadRune_Call{Call: _e.mock.On("ReadRune")}
}

func (_c *MockRuneReader_ReadRune_Call) Run(run func()) *MockRuneReader_ReadRune_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuneReader_ReadRune_Call) Return(r rune, size int, err error) *MockRuneReader_ReadRune_Call {
	_c.Call.Return(r, size, err)
	return _c
}

func (_c *MockRuneReader_ReadRune_Call) RunAndReturn(run func() (rune, int, error)) *MockRuneReader_ReadRune_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRuneScanner creates a new instance of MockRuneScanner. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRuneScanner(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRuneScanner {
	mock := &MockRuneScanner{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRuneScanner is an autogenerated mock type for the RuneScanner type
type MockRuneScanner struct {
	mock.Mock
}

type MockRuneScanner_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRuneScanner) EXPECT() *MockRuneScanner_Expecter {
	return &MockRuneScanner_Expecter{mock: &_m.Mock}
}

// ReadRune provides a mock function for the type MockRuneScanner
func (_mock *MockRuneScanner) ReadRune() (rune, int, error) {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ReadRune")
	}

	var r0 rune
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func() (rune, int, error)); ok {
		return returnFunc()
	}
	if returnFunc, ok := ret.Get(0).(func() rune); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(rune)
	}
	if returnFunc, ok := ret.Get(1).(func() int); ok {
		r1 = returnFunc()
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func() error); ok {
		r2 = returnFunc()
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockRuneScanner_ReadRune_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadRune'
type MockRuneScanner_ReadRune_Call struct {
	*mock.Call
}

// ReadRune is a helper method to define mock.On call
func (_e *MockRuneScanner_Expecter) ReadRune() *MockRuneScanner_ReadRune_Call {
	return &MockRuneScanner_ReadRune_Call{Call: _e.mock.On("ReadRune")}
}

func (_c *MockRuneScanner_ReadRune_Call) Run(run func()) *MockRuneScanner_ReadRune_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuneScanner_ReadRune_Call) Return(r rune, size int, err error) *MockRuneScanner_ReadRune_Call {
	_c.Call.Return(r, size, err)
	return _c
}

func (_c *MockRuneScanner_ReadRune_Call) RunAndReturn(run func() (rune, int, error)) *MockRuneScanner_ReadRune_Call {
	_c.Call.Return(run)
	return _c
}

// UnreadRune provides a mock function for the type MockRuneScanner
func (_mock *MockRuneScanner) UnreadRune() error {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for UnreadRune")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func() error); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRuneScanner_UnreadRune_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnreadRune'
type MockRuneScanner_UnreadRune_Call struct {
	*mock.Call
}

// UnreadRune is a helper method to define mock.On call
func (_e *MockRuneScanner_Expecter) UnreadRune() *MockRuneScanner_UnreadRune_Call {
	return &MockRuneScanner_UnreadRune_Call{Call: _e.mock.On("UnreadRune")}
}

func (_c *MockRuneScanner_UnreadRune_Call) Run(run func()) *MockRuneScanner_UnreadRune_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockRuneScanner_UnreadRune_Call) Return(err error) *MockRuneScanner_UnreadRune_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRuneScanner_UnreadRune_Call) RunAndReturn(run func() error) *MockRuneScanner_UnreadRune_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStringWriter creates a new instance of MockStringWriter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStringWriter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStringWriter {
	mock := &MockStringWriter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockStringWriter is an autogenerated mock type for the StringWriter type
type MockStringWriter struct {
	mock.Mock
}

type MockStringWriter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStringWriter) EXPECT() *MockStringWriter_Expecter {
	return &MockStringWriter_Expecter{mock: &_m.Mock}
}

// WriteString provides a mock function for the type MockStringWriter
func (_mock *MockStringWriter) WriteString(s string) (int, error) {
	ret := _mock.Called(s)

	if len(ret) == 0 {
		panic("no return value specified for WriteString")
	}

	var r0 int
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string) (int, error)); ok {
		return returnFunc(s)
	}
	if returnFunc, ok := ret.Get(0).(func(string) int); ok {
		r0 = returnFunc(s)
	} else {
		r0 = ret.Get(0).(int)
	}
	if returnFunc, ok := ret.Get(1).(func(string) error); ok {
		r1 = returnFunc(s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockStringWriter_WriteString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteString'
type MockStringWriter_WriteString_Call struct {
	*mock.Call
}

// WriteString is a helper method to define mock.On call
//   - s
func (_e *MockStringWriter_Expecter) WriteString(s interface{}) *MockStringWriter_WriteString_Call {
	return &MockStringWriter_WriteString_Call{Call: _e.mock.On("WriteString", s)}
}

func (_c *MockStringWriter_WriteString_Call) Run(run func(s string)) *MockStringWriter_WriteString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockStringWriter_WriteString_Call) Return(n int, err error) *MockStringWriter_WriteString_Call {
	_c.Call.Return(n, err)
	return _c
}

func (_c *MockStringWriter_WriteString_Call) RunAndReturn(run func(s string) (int, error)) *MockStringWriter_WriteString_Call {
	_c.Call.Return(run)
	return _c
}
