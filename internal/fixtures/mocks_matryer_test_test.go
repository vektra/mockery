// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: matryer
// TEST MOCKERY BOILERPLATE

package test

import (
	"encoding/json"
	"io"
	"net/http"
	"sync"
	"unsafe"

	http1 "github.com/vektra/mockery/v3/internal/fixtures/12345678/http"
	"github.com/vektra/mockery/v3/internal/fixtures/constraints"
	http0 "github.com/vektra/mockery/v3/internal/fixtures/http"
	test "github.com/vektra/mockery/v3/internal/fixtures/redefined_type_b"
)

// Ensure, that MoqUsesAny does implement UsesAny.
// If this is not the case, regenerate this file with moq.
var _ UsesAny = &MoqUsesAny{}

// MoqUsesAny is a mock implementation of UsesAny.
//
//	func TestSomethingThatUsesUsesAny(t *testing.T) {
//
//		// make and configure a mocked UsesAny
//		mockedUsesAny := &MoqUsesAny{
//			GetReaderFunc: func() any {
//				panic("mock out the GetReader method")
//			},
//		}
//
//		// use mockedUsesAny in code that requires UsesAny
//		// and then make assertions.
//
//	}
type MoqUsesAny struct {
	// GetReaderFunc mocks the GetReader method.
	GetReaderFunc func() any

	// calls tracks calls to the methods.
	calls struct {
		// GetReader holds details about calls to the GetReader method.
		GetReader []struct {
		}
	}
	lockGetReader sync.RWMutex
}

// GetReader calls GetReaderFunc.
func (mock *MoqUsesAny) GetReader() any {
	callInfo := struct {
	}{}
	mock.lockGetReader.Lock()
	mock.calls.GetReader = append(mock.calls.GetReader, callInfo)
	mock.lockGetReader.Unlock()
	if mock.GetReaderFunc == nil {
		var (
			v any
		)
		return v
	}
	return mock.GetReaderFunc()
}

// GetReaderCalls gets all the calls that were made to GetReader.
// Check the length with:
//
//	len(mockedUsesAny.GetReaderCalls())
func (mock *MoqUsesAny) GetReaderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetReader.RLock()
	calls = mock.calls.GetReader
	mock.lockGetReader.RUnlock()
	return calls
}

// ResetGetReaderCalls reset all the calls that were made to GetReader.
func (mock *MoqUsesAny) ResetGetReaderCalls() {
	mock.lockGetReader.Lock()
	mock.calls.GetReader = nil
	mock.lockGetReader.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqUsesAny) ResetCalls() {
	mock.lockGetReader.Lock()
	mock.calls.GetReader = nil
	mock.lockGetReader.Unlock()
}

// Ensure, that MoqFooer does implement Fooer.
// If this is not the case, regenerate this file with moq.
var _ Fooer = &MoqFooer{}

// MoqFooer is a mock implementation of Fooer.
//
//	func TestSomethingThatUsesFooer(t *testing.T) {
//
//		// make and configure a mocked Fooer
//		mockedFooer := &MoqFooer{
//			BarFunc: func(f func([]int))  {
//				panic("mock out the Bar method")
//			},
//			BazFunc: func(path string) func(x string) string {
//				panic("mock out the Baz method")
//			},
//			FooFunc: func(f func(x string) string) error {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedFooer in code that requires Fooer
//		// and then make assertions.
//
//	}
type MoqFooer struct {
	// BarFunc mocks the Bar method.
	BarFunc func(f func([]int))

	// BazFunc mocks the Baz method.
	BazFunc func(path string) func(x string) string

	// FooFunc mocks the Foo method.
	FooFunc func(f func(x string) string) error

	// calls tracks calls to the methods.
	calls struct {
		// Bar holds details about calls to the Bar method.
		Bar []struct {
			// F is the f argument value.
			F func([]int)
		}
		// Baz holds details about calls to the Baz method.
		Baz []struct {
			// Path is the path argument value.
			Path string
		}
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// F is the f argument value.
			F func(x string) string
		}
	}
	lockBar sync.RWMutex
	lockBaz sync.RWMutex
	lockFoo sync.RWMutex
}

// Bar calls BarFunc.
func (mock *MoqFooer) Bar(f func([]int)) {
	callInfo := struct {
		F func([]int)
	}{
		F: f,
	}
	mock.lockBar.Lock()
	mock.calls.Bar = append(mock.calls.Bar, callInfo)
	mock.lockBar.Unlock()
	if mock.BarFunc == nil {
		return
	}
	mock.BarFunc(f)
}

// BarCalls gets all the calls that were made to Bar.
// Check the length with:
//
//	len(mockedFooer.BarCalls())
func (mock *MoqFooer) BarCalls() []struct {
	F func([]int)
} {
	var calls []struct {
		F func([]int)
	}
	mock.lockBar.RLock()
	calls = mock.calls.Bar
	mock.lockBar.RUnlock()
	return calls
}

// ResetBarCalls reset all the calls that were made to Bar.
func (mock *MoqFooer) ResetBarCalls() {
	mock.lockBar.Lock()
	mock.calls.Bar = nil
	mock.lockBar.Unlock()
}

// Baz calls BazFunc.
func (mock *MoqFooer) Baz(path string) func(x string) string {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockBaz.Lock()
	mock.calls.Baz = append(mock.calls.Baz, callInfo)
	mock.lockBaz.Unlock()
	if mock.BazFunc == nil {
		var (
			fn func(x string) string
		)
		return fn
	}
	return mock.BazFunc(path)
}

// BazCalls gets all the calls that were made to Baz.
// Check the length with:
//
//	len(mockedFooer.BazCalls())
func (mock *MoqFooer) BazCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockBaz.RLock()
	calls = mock.calls.Baz
	mock.lockBaz.RUnlock()
	return calls
}

// ResetBazCalls reset all the calls that were made to Baz.
func (mock *MoqFooer) ResetBazCalls() {
	mock.lockBaz.Lock()
	mock.calls.Baz = nil
	mock.lockBaz.Unlock()
}

// Foo calls FooFunc.
func (mock *MoqFooer) Foo(f func(x string) string) error {
	callInfo := struct {
		F func(x string) string
	}{
		F: f,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	if mock.FooFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.FooFunc(f)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedFooer.FooCalls())
func (mock *MoqFooer) FooCalls() []struct {
	F func(x string) string
} {
	var calls []struct {
		F func(x string) string
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *MoqFooer) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqFooer) ResetCalls() {
	mock.lockBar.Lock()
	mock.calls.Bar = nil
	mock.lockBar.Unlock()

	mock.lockBaz.Lock()
	mock.calls.Baz = nil
	mock.lockBaz.Unlock()

	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// Ensure, that MoqMapFunc does implement MapFunc.
// If this is not the case, regenerate this file with moq.
var _ MapFunc = &MoqMapFunc{}

// MoqMapFunc is a mock implementation of MapFunc.
//
//	func TestSomethingThatUsesMapFunc(t *testing.T) {
//
//		// make and configure a mocked MapFunc
//		mockedMapFunc := &MoqMapFunc{
//			GetFunc: func(m map[string]func(string) string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedMapFunc in code that requires MapFunc
//		// and then make assertions.
//
//	}
type MoqMapFunc struct {
	// GetFunc mocks the Get method.
	GetFunc func(m map[string]func(string) string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// M is the m argument value.
			M map[string]func(string) string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqMapFunc) Get(m map[string]func(string) string) error {
	callInfo := struct {
		M map[string]func(string) string
	}{
		M: m,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.GetFunc(m)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedMapFunc.GetCalls())
func (mock *MoqMapFunc) GetCalls() []struct {
	M map[string]func(string) string
} {
	var calls []struct {
		M map[string]func(string) string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqMapFunc) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqMapFunc) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqAsyncProducer does implement AsyncProducer.
// If this is not the case, regenerate this file with moq.
var _ AsyncProducer = &MoqAsyncProducer{}

// MoqAsyncProducer is a mock implementation of AsyncProducer.
//
//	func TestSomethingThatUsesAsyncProducer(t *testing.T) {
//
//		// make and configure a mocked AsyncProducer
//		mockedAsyncProducer := &MoqAsyncProducer{
//			InputFunc: func() chan<- bool {
//				panic("mock out the Input method")
//			},
//			OutputFunc: func() <-chan bool {
//				panic("mock out the Output method")
//			},
//			WhateverFunc: func() chan bool {
//				panic("mock out the Whatever method")
//			},
//		}
//
//		// use mockedAsyncProducer in code that requires AsyncProducer
//		// and then make assertions.
//
//	}
type MoqAsyncProducer struct {
	// InputFunc mocks the Input method.
	InputFunc func() chan<- bool

	// OutputFunc mocks the Output method.
	OutputFunc func() <-chan bool

	// WhateverFunc mocks the Whatever method.
	WhateverFunc func() chan bool

	// calls tracks calls to the methods.
	calls struct {
		// Input holds details about calls to the Input method.
		Input []struct {
		}
		// Output holds details about calls to the Output method.
		Output []struct {
		}
		// Whatever holds details about calls to the Whatever method.
		Whatever []struct {
		}
	}
	lockInput    sync.RWMutex
	lockOutput   sync.RWMutex
	lockWhatever sync.RWMutex
}

// Input calls InputFunc.
func (mock *MoqAsyncProducer) Input() chan<- bool {
	callInfo := struct {
	}{}
	mock.lockInput.Lock()
	mock.calls.Input = append(mock.calls.Input, callInfo)
	mock.lockInput.Unlock()
	if mock.InputFunc == nil {
		var (
			boolCh chan<- bool
		)
		return boolCh
	}
	return mock.InputFunc()
}

// InputCalls gets all the calls that were made to Input.
// Check the length with:
//
//	len(mockedAsyncProducer.InputCalls())
func (mock *MoqAsyncProducer) InputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInput.RLock()
	calls = mock.calls.Input
	mock.lockInput.RUnlock()
	return calls
}

// ResetInputCalls reset all the calls that were made to Input.
func (mock *MoqAsyncProducer) ResetInputCalls() {
	mock.lockInput.Lock()
	mock.calls.Input = nil
	mock.lockInput.Unlock()
}

// Output calls OutputFunc.
func (mock *MoqAsyncProducer) Output() <-chan bool {
	callInfo := struct {
	}{}
	mock.lockOutput.Lock()
	mock.calls.Output = append(mock.calls.Output, callInfo)
	mock.lockOutput.Unlock()
	if mock.OutputFunc == nil {
		var (
			boolCh <-chan bool
		)
		return boolCh
	}
	return mock.OutputFunc()
}

// OutputCalls gets all the calls that were made to Output.
// Check the length with:
//
//	len(mockedAsyncProducer.OutputCalls())
func (mock *MoqAsyncProducer) OutputCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOutput.RLock()
	calls = mock.calls.Output
	mock.lockOutput.RUnlock()
	return calls
}

// ResetOutputCalls reset all the calls that were made to Output.
func (mock *MoqAsyncProducer) ResetOutputCalls() {
	mock.lockOutput.Lock()
	mock.calls.Output = nil
	mock.lockOutput.Unlock()
}

// Whatever calls WhateverFunc.
func (mock *MoqAsyncProducer) Whatever() chan bool {
	callInfo := struct {
	}{}
	mock.lockWhatever.Lock()
	mock.calls.Whatever = append(mock.calls.Whatever, callInfo)
	mock.lockWhatever.Unlock()
	if mock.WhateverFunc == nil {
		var (
			boolCh chan bool
		)
		return boolCh
	}
	return mock.WhateverFunc()
}

// WhateverCalls gets all the calls that were made to Whatever.
// Check the length with:
//
//	len(mockedAsyncProducer.WhateverCalls())
func (mock *MoqAsyncProducer) WhateverCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockWhatever.RLock()
	calls = mock.calls.Whatever
	mock.lockWhatever.RUnlock()
	return calls
}

// ResetWhateverCalls reset all the calls that were made to Whatever.
func (mock *MoqAsyncProducer) ResetWhateverCalls() {
	mock.lockWhatever.Lock()
	mock.calls.Whatever = nil
	mock.lockWhatever.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqAsyncProducer) ResetCalls() {
	mock.lockInput.Lock()
	mock.calls.Input = nil
	mock.lockInput.Unlock()

	mock.lockOutput.Lock()
	mock.calls.Output = nil
	mock.lockOutput.Unlock()

	mock.lockWhatever.Lock()
	mock.calls.Whatever = nil
	mock.lockWhatever.Unlock()
}

// Ensure, that MoqConsulLock does implement ConsulLock.
// If this is not the case, regenerate this file with moq.
var _ ConsulLock = &MoqConsulLock{}

// MoqConsulLock is a mock implementation of ConsulLock.
//
//	func TestSomethingThatUsesConsulLock(t *testing.T) {
//
//		// make and configure a mocked ConsulLock
//		mockedConsulLock := &MoqConsulLock{
//			LockFunc: func(valCh <-chan struct{}) (<-chan struct{}, error) {
//				panic("mock out the Lock method")
//			},
//			UnlockFunc: func() error {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedConsulLock in code that requires ConsulLock
//		// and then make assertions.
//
//	}
type MoqConsulLock struct {
	// LockFunc mocks the Lock method.
	LockFunc func(valCh <-chan struct{}) (<-chan struct{}, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Lock holds details about calls to the Lock method.
		Lock []struct {
			// ValCh is the valCh argument value.
			ValCh <-chan struct{}
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
		}
	}
	lockLock   sync.RWMutex
	lockUnlock sync.RWMutex
}

// Lock calls LockFunc.
func (mock *MoqConsulLock) Lock(valCh <-chan struct{}) (<-chan struct{}, error) {
	callInfo := struct {
		ValCh <-chan struct{}
	}{
		ValCh: valCh,
	}
	mock.lockLock.Lock()
	mock.calls.Lock = append(mock.calls.Lock, callInfo)
	mock.lockLock.Unlock()
	if mock.LockFunc == nil {
		var (
			valCh1 <-chan struct{}
			err    error
		)
		return valCh1, err
	}
	return mock.LockFunc(valCh)
}

// LockCalls gets all the calls that were made to Lock.
// Check the length with:
//
//	len(mockedConsulLock.LockCalls())
func (mock *MoqConsulLock) LockCalls() []struct {
	ValCh <-chan struct{}
} {
	var calls []struct {
		ValCh <-chan struct{}
	}
	mock.lockLock.RLock()
	calls = mock.calls.Lock
	mock.lockLock.RUnlock()
	return calls
}

// ResetLockCalls reset all the calls that were made to Lock.
func (mock *MoqConsulLock) ResetLockCalls() {
	mock.lockLock.Lock()
	mock.calls.Lock = nil
	mock.lockLock.Unlock()
}

// Unlock calls UnlockFunc.
func (mock *MoqConsulLock) Unlock() error {
	callInfo := struct {
	}{}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	if mock.UnlockFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.UnlockFunc()
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedConsulLock.UnlockCalls())
func (mock *MoqConsulLock) UnlockCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}

// ResetUnlockCalls reset all the calls that were made to Unlock.
func (mock *MoqConsulLock) ResetUnlockCalls() {
	mock.lockUnlock.Lock()
	mock.calls.Unlock = nil
	mock.lockUnlock.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqConsulLock) ResetCalls() {
	mock.lockLock.Lock()
	mock.calls.Lock = nil
	mock.lockLock.Unlock()

	mock.lockUnlock.Lock()
	mock.calls.Unlock = nil
	mock.lockUnlock.Unlock()
}

// Ensure, that MoqKeyManager does implement KeyManager.
// If this is not the case, regenerate this file with moq.
var _ KeyManager = &MoqKeyManager{}

// MoqKeyManager is a mock implementation of KeyManager.
//
//	func TestSomethingThatUsesKeyManager(t *testing.T) {
//
//		// make and configure a mocked KeyManager
//		mockedKeyManager := &MoqKeyManager{
//			GetKeyFunc: func(s string, v uint16) ([]byte, *Err) {
//				panic("mock out the GetKey method")
//			},
//		}
//
//		// use mockedKeyManager in code that requires KeyManager
//		// and then make assertions.
//
//	}
type MoqKeyManager struct {
	// GetKeyFunc mocks the GetKey method.
	GetKeyFunc func(s string, v uint16) ([]byte, *Err)

	// calls tracks calls to the methods.
	calls struct {
		// GetKey holds details about calls to the GetKey method.
		GetKey []struct {
			// S is the s argument value.
			S string
			// V is the v argument value.
			V uint16
		}
	}
	lockGetKey sync.RWMutex
}

// GetKey calls GetKeyFunc.
func (mock *MoqKeyManager) GetKey(s string, v uint16) ([]byte, *Err) {
	callInfo := struct {
		S string
		V uint16
	}{
		S: s,
		V: v,
	}
	mock.lockGetKey.Lock()
	mock.calls.GetKey = append(mock.calls.GetKey, callInfo)
	mock.lockGetKey.Unlock()
	if mock.GetKeyFunc == nil {
		var (
			bytes []byte
			err   *Err
		)
		return bytes, err
	}
	return mock.GetKeyFunc(s, v)
}

// GetKeyCalls gets all the calls that were made to GetKey.
// Check the length with:
//
//	len(mockedKeyManager.GetKeyCalls())
func (mock *MoqKeyManager) GetKeyCalls() []struct {
	S string
	V uint16
} {
	var calls []struct {
		S string
		V uint16
	}
	mock.lockGetKey.RLock()
	calls = mock.calls.GetKey
	mock.lockGetKey.RUnlock()
	return calls
}

// ResetGetKeyCalls reset all the calls that were made to GetKey.
func (mock *MoqKeyManager) ResetGetKeyCalls() {
	mock.lockGetKey.Lock()
	mock.calls.GetKey = nil
	mock.lockGetKey.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqKeyManager) ResetCalls() {
	mock.lockGetKey.Lock()
	mock.calls.GetKey = nil
	mock.lockGetKey.Unlock()
}

// Ensure, that MoqBlank does implement Blank.
// If this is not the case, regenerate this file with moq.
var _ Blank = &MoqBlank{}

// MoqBlank is a mock implementation of Blank.
//
//	func TestSomethingThatUsesBlank(t *testing.T) {
//
//		// make and configure a mocked Blank
//		mockedBlank := &MoqBlank{
//			CreateFunc: func(x interface{}) error {
//				panic("mock out the Create method")
//			},
//		}
//
//		// use mockedBlank in code that requires Blank
//		// and then make assertions.
//
//	}
type MoqBlank struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(x interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// X is the x argument value.
			X interface{}
		}
	}
	lockCreate sync.RWMutex
}

// Create calls CreateFunc.
func (mock *MoqBlank) Create(x interface{}) error {
	callInfo := struct {
		X interface{}
	}{
		X: x,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	if mock.CreateFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.CreateFunc(x)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedBlank.CreateCalls())
func (mock *MoqBlank) CreateCalls() []struct {
	X interface{}
} {
	var calls []struct {
		X interface{}
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// ResetCreateCalls reset all the calls that were made to Create.
func (mock *MoqBlank) ResetCreateCalls() {
	mock.lockCreate.Lock()
	mock.calls.Create = nil
	mock.lockCreate.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqBlank) ResetCalls() {
	mock.lockCreate.Lock()
	mock.calls.Create = nil
	mock.lockCreate.Unlock()
}

// Ensure, that MoqExpecter does implement Expecter.
// If this is not the case, regenerate this file with moq.
var _ Expecter = &MoqExpecter{}

// MoqExpecter is a mock implementation of Expecter.
//
//	func TestSomethingThatUsesExpecter(t *testing.T) {
//
//		// make and configure a mocked Expecter
//		mockedExpecter := &MoqExpecter{
//			ManyArgsReturnsFunc: func(str string, i int) ([]string, error) {
//				panic("mock out the ManyArgsReturns method")
//			},
//			NoArgFunc: func() string {
//				panic("mock out the NoArg method")
//			},
//			NoReturnFunc: func(str string)  {
//				panic("mock out the NoReturn method")
//			},
//			VariadicFunc: func(ints ...int) error {
//				panic("mock out the Variadic method")
//			},
//			VariadicManyFunc: func(i int, a string, intfs ...interface{}) error {
//				panic("mock out the VariadicMany method")
//			},
//		}
//
//		// use mockedExpecter in code that requires Expecter
//		// and then make assertions.
//
//	}
type MoqExpecter struct {
	// ManyArgsReturnsFunc mocks the ManyArgsReturns method.
	ManyArgsReturnsFunc func(str string, i int) ([]string, error)

	// NoArgFunc mocks the NoArg method.
	NoArgFunc func() string

	// NoReturnFunc mocks the NoReturn method.
	NoReturnFunc func(str string)

	// VariadicFunc mocks the Variadic method.
	VariadicFunc func(ints ...int) error

	// VariadicManyFunc mocks the VariadicMany method.
	VariadicManyFunc func(i int, a string, intfs ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// ManyArgsReturns holds details about calls to the ManyArgsReturns method.
		ManyArgsReturns []struct {
			// Str is the str argument value.
			Str string
			// I is the i argument value.
			I int
		}
		// NoArg holds details about calls to the NoArg method.
		NoArg []struct {
		}
		// NoReturn holds details about calls to the NoReturn method.
		NoReturn []struct {
			// Str is the str argument value.
			Str string
		}
		// Variadic holds details about calls to the Variadic method.
		Variadic []struct {
			// Ints is the ints argument value.
			Ints []int
		}
		// VariadicMany holds details about calls to the VariadicMany method.
		VariadicMany []struct {
			// I is the i argument value.
			I int
			// A is the a argument value.
			A string
			// Intfs is the intfs argument value.
			Intfs []interface{}
		}
	}
	lockManyArgsReturns sync.RWMutex
	lockNoArg           sync.RWMutex
	lockNoReturn        sync.RWMutex
	lockVariadic        sync.RWMutex
	lockVariadicMany    sync.RWMutex
}

// ManyArgsReturns calls ManyArgsReturnsFunc.
func (mock *MoqExpecter) ManyArgsReturns(str string, i int) ([]string, error) {
	callInfo := struct {
		Str string
		I   int
	}{
		Str: str,
		I:   i,
	}
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = append(mock.calls.ManyArgsReturns, callInfo)
	mock.lockManyArgsReturns.Unlock()
	if mock.ManyArgsReturnsFunc == nil {
		var (
			strs []string
			err  error
		)
		return strs, err
	}
	return mock.ManyArgsReturnsFunc(str, i)
}

// ManyArgsReturnsCalls gets all the calls that were made to ManyArgsReturns.
// Check the length with:
//
//	len(mockedExpecter.ManyArgsReturnsCalls())
func (mock *MoqExpecter) ManyArgsReturnsCalls() []struct {
	Str string
	I   int
} {
	var calls []struct {
		Str string
		I   int
	}
	mock.lockManyArgsReturns.RLock()
	calls = mock.calls.ManyArgsReturns
	mock.lockManyArgsReturns.RUnlock()
	return calls
}

// ResetManyArgsReturnsCalls reset all the calls that were made to ManyArgsReturns.
func (mock *MoqExpecter) ResetManyArgsReturnsCalls() {
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = nil
	mock.lockManyArgsReturns.Unlock()
}

// NoArg calls NoArgFunc.
func (mock *MoqExpecter) NoArg() string {
	callInfo := struct {
	}{}
	mock.lockNoArg.Lock()
	mock.calls.NoArg = append(mock.calls.NoArg, callInfo)
	mock.lockNoArg.Unlock()
	if mock.NoArgFunc == nil {
		var (
			s string
		)
		return s
	}
	return mock.NoArgFunc()
}

// NoArgCalls gets all the calls that were made to NoArg.
// Check the length with:
//
//	len(mockedExpecter.NoArgCalls())
func (mock *MoqExpecter) NoArgCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNoArg.RLock()
	calls = mock.calls.NoArg
	mock.lockNoArg.RUnlock()
	return calls
}

// ResetNoArgCalls reset all the calls that were made to NoArg.
func (mock *MoqExpecter) ResetNoArgCalls() {
	mock.lockNoArg.Lock()
	mock.calls.NoArg = nil
	mock.lockNoArg.Unlock()
}

// NoReturn calls NoReturnFunc.
func (mock *MoqExpecter) NoReturn(str string) {
	callInfo := struct {
		Str string
	}{
		Str: str,
	}
	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = append(mock.calls.NoReturn, callInfo)
	mock.lockNoReturn.Unlock()
	if mock.NoReturnFunc == nil {
		return
	}
	mock.NoReturnFunc(str)
}

// NoReturnCalls gets all the calls that were made to NoReturn.
// Check the length with:
//
//	len(mockedExpecter.NoReturnCalls())
func (mock *MoqExpecter) NoReturnCalls() []struct {
	Str string
} {
	var calls []struct {
		Str string
	}
	mock.lockNoReturn.RLock()
	calls = mock.calls.NoReturn
	mock.lockNoReturn.RUnlock()
	return calls
}

// ResetNoReturnCalls reset all the calls that were made to NoReturn.
func (mock *MoqExpecter) ResetNoReturnCalls() {
	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = nil
	mock.lockNoReturn.Unlock()
}

// Variadic calls VariadicFunc.
func (mock *MoqExpecter) Variadic(ints ...int) error {
	callInfo := struct {
		Ints []int
	}{
		Ints: ints,
	}
	mock.lockVariadic.Lock()
	mock.calls.Variadic = append(mock.calls.Variadic, callInfo)
	mock.lockVariadic.Unlock()
	if mock.VariadicFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.VariadicFunc(ints...)
}

// VariadicCalls gets all the calls that were made to Variadic.
// Check the length with:
//
//	len(mockedExpecter.VariadicCalls())
func (mock *MoqExpecter) VariadicCalls() []struct {
	Ints []int
} {
	var calls []struct {
		Ints []int
	}
	mock.lockVariadic.RLock()
	calls = mock.calls.Variadic
	mock.lockVariadic.RUnlock()
	return calls
}

// ResetVariadicCalls reset all the calls that were made to Variadic.
func (mock *MoqExpecter) ResetVariadicCalls() {
	mock.lockVariadic.Lock()
	mock.calls.Variadic = nil
	mock.lockVariadic.Unlock()
}

// VariadicMany calls VariadicManyFunc.
func (mock *MoqExpecter) VariadicMany(i int, a string, intfs ...interface{}) error {
	callInfo := struct {
		I     int
		A     string
		Intfs []interface{}
	}{
		I:     i,
		A:     a,
		Intfs: intfs,
	}
	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = append(mock.calls.VariadicMany, callInfo)
	mock.lockVariadicMany.Unlock()
	if mock.VariadicManyFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.VariadicManyFunc(i, a, intfs...)
}

// VariadicManyCalls gets all the calls that were made to VariadicMany.
// Check the length with:
//
//	len(mockedExpecter.VariadicManyCalls())
func (mock *MoqExpecter) VariadicManyCalls() []struct {
	I     int
	A     string
	Intfs []interface{}
} {
	var calls []struct {
		I     int
		A     string
		Intfs []interface{}
	}
	mock.lockVariadicMany.RLock()
	calls = mock.calls.VariadicMany
	mock.lockVariadicMany.RUnlock()
	return calls
}

// ResetVariadicManyCalls reset all the calls that were made to VariadicMany.
func (mock *MoqExpecter) ResetVariadicManyCalls() {
	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = nil
	mock.lockVariadicMany.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqExpecter) ResetCalls() {
	mock.lockManyArgsReturns.Lock()
	mock.calls.ManyArgsReturns = nil
	mock.lockManyArgsReturns.Unlock()

	mock.lockNoArg.Lock()
	mock.calls.NoArg = nil
	mock.lockNoArg.Unlock()

	mock.lockNoReturn.Lock()
	mock.calls.NoReturn = nil
	mock.lockNoReturn.Unlock()

	mock.lockVariadic.Lock()
	mock.calls.Variadic = nil
	mock.lockVariadic.Unlock()

	mock.lockVariadicMany.Lock()
	mock.calls.VariadicMany = nil
	mock.lockVariadicMany.Unlock()
}

// Ensure, that MoqVariadicNoReturnInterface does implement VariadicNoReturnInterface.
// If this is not the case, regenerate this file with moq.
var _ VariadicNoReturnInterface = &MoqVariadicNoReturnInterface{}

// MoqVariadicNoReturnInterface is a mock implementation of VariadicNoReturnInterface.
//
//	func TestSomethingThatUsesVariadicNoReturnInterface(t *testing.T) {
//
//		// make and configure a mocked VariadicNoReturnInterface
//		mockedVariadicNoReturnInterface := &MoqVariadicNoReturnInterface{
//			VariadicNoReturnFunc: func(j int, is ...interface{})  {
//				panic("mock out the VariadicNoReturn method")
//			},
//		}
//
//		// use mockedVariadicNoReturnInterface in code that requires VariadicNoReturnInterface
//		// and then make assertions.
//
//	}
type MoqVariadicNoReturnInterface struct {
	// VariadicNoReturnFunc mocks the VariadicNoReturn method.
	VariadicNoReturnFunc func(j int, is ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// VariadicNoReturn holds details about calls to the VariadicNoReturn method.
		VariadicNoReturn []struct {
			// J is the j argument value.
			J int
			// Is is the is argument value.
			Is []interface{}
		}
	}
	lockVariadicNoReturn sync.RWMutex
}

// VariadicNoReturn calls VariadicNoReturnFunc.
func (mock *MoqVariadicNoReturnInterface) VariadicNoReturn(j int, is ...interface{}) {
	callInfo := struct {
		J  int
		Is []interface{}
	}{
		J:  j,
		Is: is,
	}
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = append(mock.calls.VariadicNoReturn, callInfo)
	mock.lockVariadicNoReturn.Unlock()
	if mock.VariadicNoReturnFunc == nil {
		return
	}
	mock.VariadicNoReturnFunc(j, is...)
}

// VariadicNoReturnCalls gets all the calls that were made to VariadicNoReturn.
// Check the length with:
//
//	len(mockedVariadicNoReturnInterface.VariadicNoReturnCalls())
func (mock *MoqVariadicNoReturnInterface) VariadicNoReturnCalls() []struct {
	J  int
	Is []interface{}
} {
	var calls []struct {
		J  int
		Is []interface{}
	}
	mock.lockVariadicNoReturn.RLock()
	calls = mock.calls.VariadicNoReturn
	mock.lockVariadicNoReturn.RUnlock()
	return calls
}

// ResetVariadicNoReturnCalls reset all the calls that were made to VariadicNoReturn.
func (mock *MoqVariadicNoReturnInterface) ResetVariadicNoReturnCalls() {
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = nil
	mock.lockVariadicNoReturn.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqVariadicNoReturnInterface) ResetCalls() {
	mock.lockVariadicNoReturn.Lock()
	mock.calls.VariadicNoReturn = nil
	mock.lockVariadicNoReturn.Unlock()
}

// Ensure, that MoqFuncArgsCollision does implement FuncArgsCollision.
// If this is not the case, regenerate this file with moq.
var _ FuncArgsCollision = &MoqFuncArgsCollision{}

// MoqFuncArgsCollision is a mock implementation of FuncArgsCollision.
//
//	func TestSomethingThatUsesFuncArgsCollision(t *testing.T) {
//
//		// make and configure a mocked FuncArgsCollision
//		mockedFuncArgsCollision := &MoqFuncArgsCollision{
//			FooFunc: func(ret interface{}) error {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedFuncArgsCollision in code that requires FuncArgsCollision
//		// and then make assertions.
//
//	}
type MoqFuncArgsCollision struct {
	// FooFunc mocks the Foo method.
	FooFunc func(ret interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// Ret is the ret argument value.
			Ret interface{}
		}
	}
	lockFoo sync.RWMutex
}

// Foo calls FooFunc.
func (mock *MoqFuncArgsCollision) Foo(ret interface{}) error {
	callInfo := struct {
		Ret interface{}
	}{
		Ret: ret,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	if mock.FooFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.FooFunc(ret)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedFuncArgsCollision.FooCalls())
func (mock *MoqFuncArgsCollision) FooCalls() []struct {
	Ret interface{}
} {
	var calls []struct {
		Ret interface{}
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *MoqFuncArgsCollision) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqFuncArgsCollision) ResetCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// Ensure, that MoqGetInt does implement GetInt.
// If this is not the case, regenerate this file with moq.
var _ GetInt = &MoqGetInt{}

// MoqGetInt is a mock implementation of GetInt.
//
//	func TestSomethingThatUsesGetInt(t *testing.T) {
//
//		// make and configure a mocked GetInt
//		mockedGetInt := &MoqGetInt{
//			GetFunc: func() int {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedGetInt in code that requires GetInt
//		// and then make assertions.
//
//	}
type MoqGetInt struct {
	// GetFunc mocks the Get method.
	GetFunc func() int

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqGetInt) Get() int {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			n int
		)
		return n
	}
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGetInt.GetCalls())
func (mock *MoqGetInt) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqGetInt) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqGetInt) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqGetGeneric does implement GetGeneric.
// If this is not the case, regenerate this file with moq.
var _ GetGeneric[int] = &MoqGetGeneric[int]{}

// MoqGetGeneric is a mock implementation of GetGeneric.
//
//	func TestSomethingThatUsesGetGeneric(t *testing.T) {
//
//		// make and configure a mocked GetGeneric
//		mockedGetGeneric := &MoqGetGeneric{
//			GetFunc: func() T {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedGetGeneric in code that requires GetGeneric
//		// and then make assertions.
//
//	}
type MoqGetGeneric[T constraints.Integer] struct {
	// GetFunc mocks the Get method.
	GetFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqGetGeneric[T]) Get() T {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			v T
		)
		return v
	}
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedGetGeneric.GetCalls())
func (mock *MoqGetGeneric[T]) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqGetGeneric[T]) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqGetGeneric[T]) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqEmbeddedGet does implement EmbeddedGet.
// If this is not the case, regenerate this file with moq.
var _ EmbeddedGet[int] = &MoqEmbeddedGet[int]{}

// MoqEmbeddedGet is a mock implementation of EmbeddedGet.
//
//	func TestSomethingThatUsesEmbeddedGet(t *testing.T) {
//
//		// make and configure a mocked EmbeddedGet
//		mockedEmbeddedGet := &MoqEmbeddedGet{
//			GetFunc: func() T {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedEmbeddedGet in code that requires EmbeddedGet
//		// and then make assertions.
//
//	}
type MoqEmbeddedGet[T constraints.Signed] struct {
	// GetFunc mocks the Get method.
	GetFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqEmbeddedGet[T]) Get() T {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			v T
		)
		return v
	}
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedEmbeddedGet.GetCalls())
func (mock *MoqEmbeddedGet[T]) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqEmbeddedGet[T]) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqEmbeddedGet[T]) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqReplaceGeneric does implement ReplaceGeneric.
// If this is not the case, regenerate this file with moq.
var _ ReplaceGeneric[any, int, any] = &MoqReplaceGeneric[any, int, any]{}

// MoqReplaceGeneric is a mock implementation of ReplaceGeneric.
//
//	func TestSomethingThatUsesReplaceGeneric(t *testing.T) {
//
//		// make and configure a mocked ReplaceGeneric
//		mockedReplaceGeneric := &MoqReplaceGeneric{
//			AFunc: func(t1 TImport) TKeep {
//				panic("mock out the A method")
//			},
//			BFunc: func() TImport {
//				panic("mock out the B method")
//			},
//			CFunc: func() TConstraint {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedReplaceGeneric in code that requires ReplaceGeneric
//		// and then make assertions.
//
//	}
type MoqReplaceGeneric[TImport any, TConstraint constraints.Signed, TKeep any] struct {
	// AFunc mocks the A method.
	AFunc func(t1 TImport) TKeep

	// BFunc mocks the B method.
	BFunc func() TImport

	// CFunc mocks the C method.
	CFunc func() TConstraint

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
			// T1 is the t1 argument value.
			T1 TImport
		}
		// B holds details about calls to the B method.
		B []struct {
		}
		// C holds details about calls to the C method.
		C []struct {
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) A(t1 TImport) TKeep {
	callInfo := struct {
		T1 TImport
	}{
		T1: t1,
	}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	if mock.AFunc == nil {
		var (
			v TKeep
		)
		return v
	}
	return mock.AFunc(t1)
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedReplaceGeneric.ACalls())
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) ACalls() []struct {
	T1 TImport
} {
	var calls []struct {
		T1 TImport
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) B() TImport {
	callInfo := struct {
	}{}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	if mock.BFunc == nil {
		var (
			v TImport
		)
		return v
	}
	return mock.BFunc()
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedReplaceGeneric.BCalls())
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) BCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) C() TConstraint {
	callInfo := struct {
	}{}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	if mock.CFunc == nil {
		var (
			v TConstraint
		)
		return v
	}
	return mock.CFunc()
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedReplaceGeneric.CCalls())
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) CCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqReplaceGeneric[TImport, TConstraint, TKeep]) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// Ensure, that MoqReplaceGenericSelf does implement ReplaceGenericSelf.
// If this is not the case, regenerate this file with moq.
var _ ReplaceGenericSelf[any] = &MoqReplaceGenericSelf[any]{}

// MoqReplaceGenericSelf is a mock implementation of ReplaceGenericSelf.
//
//	func TestSomethingThatUsesReplaceGenericSelf(t *testing.T) {
//
//		// make and configure a mocked ReplaceGenericSelf
//		mockedReplaceGenericSelf := &MoqReplaceGenericSelf{
//			AFunc: func() T {
//				panic("mock out the A method")
//			},
//		}
//
//		// use mockedReplaceGenericSelf in code that requires ReplaceGenericSelf
//		// and then make assertions.
//
//	}
type MoqReplaceGenericSelf[T any] struct {
	// AFunc mocks the A method.
	AFunc func() T

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
	}
	lockA sync.RWMutex
}

// A calls AFunc.
func (mock *MoqReplaceGenericSelf[T]) A() T {
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	if mock.AFunc == nil {
		var (
			v T
		)
		return v
	}
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedReplaceGenericSelf.ACalls())
func (mock *MoqReplaceGenericSelf[T]) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *MoqReplaceGenericSelf[T]) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqReplaceGenericSelf[T]) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// Ensure, that MoqHasConflictingNestedImports does implement HasConflictingNestedImports.
// If this is not the case, regenerate this file with moq.
var _ HasConflictingNestedImports = &MoqHasConflictingNestedImports{}

// MoqHasConflictingNestedImports is a mock implementation of HasConflictingNestedImports.
//
//	func TestSomethingThatUsesHasConflictingNestedImports(t *testing.T) {
//
//		// make and configure a mocked HasConflictingNestedImports
//		mockedHasConflictingNestedImports := &MoqHasConflictingNestedImports{
//			GetFunc: func(path string) (http.Response, error) {
//				panic("mock out the Get method")
//			},
//			ZFunc: func() http0.MyStruct {
//				panic("mock out the Z method")
//			},
//		}
//
//		// use mockedHasConflictingNestedImports in code that requires HasConflictingNestedImports
//		// and then make assertions.
//
//	}
type MoqHasConflictingNestedImports struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (http.Response, error)

	// ZFunc mocks the Z method.
	ZFunc func() http0.MyStruct

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
		// Z holds details about calls to the Z method.
		Z []struct {
		}
	}
	lockGet sync.RWMutex
	lockZ   sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqHasConflictingNestedImports) Get(path string) (http.Response, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			response http.Response
			err      error
		)
		return response, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedHasConflictingNestedImports.GetCalls())
func (mock *MoqHasConflictingNestedImports) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqHasConflictingNestedImports) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Z calls ZFunc.
func (mock *MoqHasConflictingNestedImports) Z() http0.MyStruct {
	callInfo := struct {
	}{}
	mock.lockZ.Lock()
	mock.calls.Z = append(mock.calls.Z, callInfo)
	mock.lockZ.Unlock()
	if mock.ZFunc == nil {
		var (
			myStruct http0.MyStruct
		)
		return myStruct
	}
	return mock.ZFunc()
}

// ZCalls gets all the calls that were made to Z.
// Check the length with:
//
//	len(mockedHasConflictingNestedImports.ZCalls())
func (mock *MoqHasConflictingNestedImports) ZCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockZ.RLock()
	calls = mock.calls.Z
	mock.lockZ.RUnlock()
	return calls
}

// ResetZCalls reset all the calls that were made to Z.
func (mock *MoqHasConflictingNestedImports) ResetZCalls() {
	mock.lockZ.Lock()
	mock.calls.Z = nil
	mock.lockZ.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqHasConflictingNestedImports) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockZ.Lock()
	mock.calls.Z = nil
	mock.lockZ.Unlock()
}

// Ensure, that MoqImportsSameAsPackage does implement ImportsSameAsPackage.
// If this is not the case, regenerate this file with moq.
var _ ImportsSameAsPackage = &MoqImportsSameAsPackage{}

// MoqImportsSameAsPackage is a mock implementation of ImportsSameAsPackage.
//
//	func TestSomethingThatUsesImportsSameAsPackage(t *testing.T) {
//
//		// make and configure a mocked ImportsSameAsPackage
//		mockedImportsSameAsPackage := &MoqImportsSameAsPackage{
//			AFunc: func() test.B {
//				panic("mock out the A method")
//			},
//			BFunc: func() KeyManager {
//				panic("mock out the B method")
//			},
//			CFunc: func(c C)  {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedImportsSameAsPackage in code that requires ImportsSameAsPackage
//		// and then make assertions.
//
//	}
type MoqImportsSameAsPackage struct {
	// AFunc mocks the A method.
	AFunc func() test.B

	// BFunc mocks the B method.
	BFunc func() KeyManager

	// CFunc mocks the C method.
	CFunc func(c C)

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
		// B holds details about calls to the B method.
		B []struct {
		}
		// C holds details about calls to the C method.
		C []struct {
			// C is the c argument value.
			C C
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *MoqImportsSameAsPackage) A() test.B {
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	if mock.AFunc == nil {
		var (
			b test.B
		)
		return b
	}
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.ACalls())
func (mock *MoqImportsSameAsPackage) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *MoqImportsSameAsPackage) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *MoqImportsSameAsPackage) B() KeyManager {
	callInfo := struct {
	}{}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	if mock.BFunc == nil {
		var (
			keyManager KeyManager
		)
		return keyManager
	}
	return mock.BFunc()
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.BCalls())
func (mock *MoqImportsSameAsPackage) BCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *MoqImportsSameAsPackage) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *MoqImportsSameAsPackage) C(c C) {
	callInfo := struct {
		C C
	}{
		C: c,
	}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	if mock.CFunc == nil {
		return
	}
	mock.CFunc(c)
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedImportsSameAsPackage.CCalls())
func (mock *MoqImportsSameAsPackage) CCalls() []struct {
	C C
} {
	var calls []struct {
		C C
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *MoqImportsSameAsPackage) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqImportsSameAsPackage) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// Ensure, that MoqGenericInterface does implement GenericInterface.
// If this is not the case, regenerate this file with moq.
var _ GenericInterface[any] = &MoqGenericInterface[any]{}

// MoqGenericInterface is a mock implementation of GenericInterface.
//
//	func TestSomethingThatUsesGenericInterface(t *testing.T) {
//
//		// make and configure a mocked GenericInterface
//		mockedGenericInterface := &MoqGenericInterface{
//			FuncFunc: func(arg *M) int {
//				panic("mock out the Func method")
//			},
//		}
//
//		// use mockedGenericInterface in code that requires GenericInterface
//		// and then make assertions.
//
//	}
type MoqGenericInterface[M any] struct {
	// FuncFunc mocks the Func method.
	FuncFunc func(arg *M) int

	// calls tracks calls to the methods.
	calls struct {
		// Func holds details about calls to the Func method.
		Func []struct {
			// Arg is the arg argument value.
			Arg *M
		}
	}
	lockFunc sync.RWMutex
}

// Func calls FuncFunc.
func (mock *MoqGenericInterface[M]) Func(arg *M) int {
	callInfo := struct {
		Arg *M
	}{
		Arg: arg,
	}
	mock.lockFunc.Lock()
	mock.calls.Func = append(mock.calls.Func, callInfo)
	mock.lockFunc.Unlock()
	if mock.FuncFunc == nil {
		var (
			n int
		)
		return n
	}
	return mock.FuncFunc(arg)
}

// FuncCalls gets all the calls that were made to Func.
// Check the length with:
//
//	len(mockedGenericInterface.FuncCalls())
func (mock *MoqGenericInterface[M]) FuncCalls() []struct {
	Arg *M
} {
	var calls []struct {
		Arg *M
	}
	mock.lockFunc.RLock()
	calls = mock.calls.Func
	mock.lockFunc.RUnlock()
	return calls
}

// ResetFuncCalls reset all the calls that were made to Func.
func (mock *MoqGenericInterface[M]) ResetFuncCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqGenericInterface[M]) ResetCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// Ensure, that MoqInstantiatedGenericInterface does implement InstantiatedGenericInterface.
// If this is not the case, regenerate this file with moq.
var _ InstantiatedGenericInterface = &MoqInstantiatedGenericInterface{}

// MoqInstantiatedGenericInterface is a mock implementation of InstantiatedGenericInterface.
//
//	func TestSomethingThatUsesInstantiatedGenericInterface(t *testing.T) {
//
//		// make and configure a mocked InstantiatedGenericInterface
//		mockedInstantiatedGenericInterface := &MoqInstantiatedGenericInterface{
//			FuncFunc: func(arg *float32) int {
//				panic("mock out the Func method")
//			},
//		}
//
//		// use mockedInstantiatedGenericInterface in code that requires InstantiatedGenericInterface
//		// and then make assertions.
//
//	}
type MoqInstantiatedGenericInterface struct {
	// FuncFunc mocks the Func method.
	FuncFunc func(arg *float32) int

	// calls tracks calls to the methods.
	calls struct {
		// Func holds details about calls to the Func method.
		Func []struct {
			// Arg is the arg argument value.
			Arg *float32
		}
	}
	lockFunc sync.RWMutex
}

// Func calls FuncFunc.
func (mock *MoqInstantiatedGenericInterface) Func(arg *float32) int {
	callInfo := struct {
		Arg *float32
	}{
		Arg: arg,
	}
	mock.lockFunc.Lock()
	mock.calls.Func = append(mock.calls.Func, callInfo)
	mock.lockFunc.Unlock()
	if mock.FuncFunc == nil {
		var (
			n int
		)
		return n
	}
	return mock.FuncFunc(arg)
}

// FuncCalls gets all the calls that were made to Func.
// Check the length with:
//
//	len(mockedInstantiatedGenericInterface.FuncCalls())
func (mock *MoqInstantiatedGenericInterface) FuncCalls() []struct {
	Arg *float32
} {
	var calls []struct {
		Arg *float32
	}
	mock.lockFunc.RLock()
	calls = mock.calls.Func
	mock.lockFunc.RUnlock()
	return calls
}

// ResetFuncCalls reset all the calls that were made to Func.
func (mock *MoqInstantiatedGenericInterface) ResetFuncCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqInstantiatedGenericInterface) ResetCalls() {
	mock.lockFunc.Lock()
	mock.calls.Func = nil
	mock.lockFunc.Unlock()
}

// Ensure, that MoqMyReader does implement MyReader.
// If this is not the case, regenerate this file with moq.
var _ MyReader = &MoqMyReader{}

// MoqMyReader is a mock implementation of MyReader.
//
//	func TestSomethingThatUsesMyReader(t *testing.T) {
//
//		// make and configure a mocked MyReader
//		mockedMyReader := &MoqMyReader{
//			ReadFunc: func(p []byte) (int, error) {
//				panic("mock out the Read method")
//			},
//		}
//
//		// use mockedMyReader in code that requires MyReader
//		// and then make assertions.
//
//	}
type MoqMyReader struct {
	// ReadFunc mocks the Read method.
	ReadFunc func(p []byte) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Read holds details about calls to the Read method.
		Read []struct {
			// P is the p argument value.
			P []byte
		}
	}
	lockRead sync.RWMutex
}

// Read calls ReadFunc.
func (mock *MoqMyReader) Read(p []byte) (int, error) {
	callInfo := struct {
		P []byte
	}{
		P: p,
	}
	mock.lockRead.Lock()
	mock.calls.Read = append(mock.calls.Read, callInfo)
	mock.lockRead.Unlock()
	if mock.ReadFunc == nil {
		var (
			n   int
			err error
		)
		return n, err
	}
	return mock.ReadFunc(p)
}

// ReadCalls gets all the calls that were made to Read.
// Check the length with:
//
//	len(mockedMyReader.ReadCalls())
func (mock *MoqMyReader) ReadCalls() []struct {
	P []byte
} {
	var calls []struct {
		P []byte
	}
	mock.lockRead.RLock()
	calls = mock.calls.Read
	mock.lockRead.RUnlock()
	return calls
}

// ResetReadCalls reset all the calls that were made to Read.
func (mock *MoqMyReader) ResetReadCalls() {
	mock.lockRead.Lock()
	mock.calls.Read = nil
	mock.lockRead.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqMyReader) ResetCalls() {
	mock.lockRead.Lock()
	mock.calls.Read = nil
	mock.lockRead.Unlock()
}

// Ensure, that MoqIssue766 does implement Issue766.
// If this is not the case, regenerate this file with moq.
var _ Issue766 = &MoqIssue766{}

// MoqIssue766 is a mock implementation of Issue766.
//
//	func TestSomethingThatUsesIssue766(t *testing.T) {
//
//		// make and configure a mocked Issue766
//		mockedIssue766 := &MoqIssue766{
//			FetchDataFunc: func(fetchFunc func(x ...int) ([]int, error)) ([]int, error) {
//				panic("mock out the FetchData method")
//			},
//		}
//
//		// use mockedIssue766 in code that requires Issue766
//		// and then make assertions.
//
//	}
type MoqIssue766 struct {
	// FetchDataFunc mocks the FetchData method.
	FetchDataFunc func(fetchFunc func(x ...int) ([]int, error)) ([]int, error)

	// calls tracks calls to the methods.
	calls struct {
		// FetchData holds details about calls to the FetchData method.
		FetchData []struct {
			// FetchFunc is the fetchFunc argument value.
			FetchFunc func(x ...int) ([]int, error)
		}
	}
	lockFetchData sync.RWMutex
}

// FetchData calls FetchDataFunc.
func (mock *MoqIssue766) FetchData(fetchFunc func(x ...int) ([]int, error)) ([]int, error) {
	callInfo := struct {
		FetchFunc func(x ...int) ([]int, error)
	}{
		FetchFunc: fetchFunc,
	}
	mock.lockFetchData.Lock()
	mock.calls.FetchData = append(mock.calls.FetchData, callInfo)
	mock.lockFetchData.Unlock()
	if mock.FetchDataFunc == nil {
		var (
			ints []int
			err  error
		)
		return ints, err
	}
	return mock.FetchDataFunc(fetchFunc)
}

// FetchDataCalls gets all the calls that were made to FetchData.
// Check the length with:
//
//	len(mockedIssue766.FetchDataCalls())
func (mock *MoqIssue766) FetchDataCalls() []struct {
	FetchFunc func(x ...int) ([]int, error)
} {
	var calls []struct {
		FetchFunc func(x ...int) ([]int, error)
	}
	mock.lockFetchData.RLock()
	calls = mock.calls.FetchData
	mock.lockFetchData.RUnlock()
	return calls
}

// ResetFetchDataCalls reset all the calls that were made to FetchData.
func (mock *MoqIssue766) ResetFetchDataCalls() {
	mock.lockFetchData.Lock()
	mock.calls.FetchData = nil
	mock.lockFetchData.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqIssue766) ResetCalls() {
	mock.lockFetchData.Lock()
	mock.calls.FetchData = nil
	mock.lockFetchData.Unlock()
}

// Ensure, that MoqMapToInterface does implement MapToInterface.
// If this is not the case, regenerate this file with moq.
var _ MapToInterface = &MoqMapToInterface{}

// MoqMapToInterface is a mock implementation of MapToInterface.
//
//	func TestSomethingThatUsesMapToInterface(t *testing.T) {
//
//		// make and configure a mocked MapToInterface
//		mockedMapToInterface := &MoqMapToInterface{
//			FooFunc: func(arg1 ...map[string]interface{})  {
//				panic("mock out the Foo method")
//			},
//		}
//
//		// use mockedMapToInterface in code that requires MapToInterface
//		// and then make assertions.
//
//	}
type MoqMapToInterface struct {
	// FooFunc mocks the Foo method.
	FooFunc func(arg1 ...map[string]interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Foo holds details about calls to the Foo method.
		Foo []struct {
			// Arg1 is the arg1 argument value.
			Arg1 []map[string]interface{}
		}
	}
	lockFoo sync.RWMutex
}

// Foo calls FooFunc.
func (mock *MoqMapToInterface) Foo(arg1 ...map[string]interface{}) {
	callInfo := struct {
		Arg1 []map[string]interface{}
	}{
		Arg1: arg1,
	}
	mock.lockFoo.Lock()
	mock.calls.Foo = append(mock.calls.Foo, callInfo)
	mock.lockFoo.Unlock()
	if mock.FooFunc == nil {
		return
	}
	mock.FooFunc(arg1...)
}

// FooCalls gets all the calls that were made to Foo.
// Check the length with:
//
//	len(mockedMapToInterface.FooCalls())
func (mock *MoqMapToInterface) FooCalls() []struct {
	Arg1 []map[string]interface{}
} {
	var calls []struct {
		Arg1 []map[string]interface{}
	}
	mock.lockFoo.RLock()
	calls = mock.calls.Foo
	mock.lockFoo.RUnlock()
	return calls
}

// ResetFooCalls reset all the calls that were made to Foo.
func (mock *MoqMapToInterface) ResetFooCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqMapToInterface) ResetCalls() {
	mock.lockFoo.Lock()
	mock.calls.Foo = nil
	mock.lockFoo.Unlock()
}

// Ensure, that MoqSibling does implement Sibling.
// If this is not the case, regenerate this file with moq.
var _ Sibling = &MoqSibling{}

// MoqSibling is a mock implementation of Sibling.
//
//	func TestSomethingThatUsesSibling(t *testing.T) {
//
//		// make and configure a mocked Sibling
//		mockedSibling := &MoqSibling{
//			DoSomethingFunc: func()  {
//				panic("mock out the DoSomething method")
//			},
//		}
//
//		// use mockedSibling in code that requires Sibling
//		// and then make assertions.
//
//	}
type MoqSibling struct {
	// DoSomethingFunc mocks the DoSomething method.
	DoSomethingFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// DoSomething holds details about calls to the DoSomething method.
		DoSomething []struct {
		}
	}
	lockDoSomething sync.RWMutex
}

// DoSomething calls DoSomethingFunc.
func (mock *MoqSibling) DoSomething() {
	callInfo := struct {
	}{}
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = append(mock.calls.DoSomething, callInfo)
	mock.lockDoSomething.Unlock()
	if mock.DoSomethingFunc == nil {
		return
	}
	mock.DoSomethingFunc()
}

// DoSomethingCalls gets all the calls that were made to DoSomething.
// Check the length with:
//
//	len(mockedSibling.DoSomethingCalls())
func (mock *MoqSibling) DoSomethingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoSomething.RLock()
	calls = mock.calls.DoSomething
	mock.lockDoSomething.RUnlock()
	return calls
}

// ResetDoSomethingCalls reset all the calls that were made to DoSomething.
func (mock *MoqSibling) ResetDoSomethingCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqSibling) ResetCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// Ensure, that MoqUsesOtherPkgIface does implement UsesOtherPkgIface.
// If this is not the case, regenerate this file with moq.
var _ UsesOtherPkgIface = &MoqUsesOtherPkgIface{}

// MoqUsesOtherPkgIface is a mock implementation of UsesOtherPkgIface.
//
//	func TestSomethingThatUsesUsesOtherPkgIface(t *testing.T) {
//
//		// make and configure a mocked UsesOtherPkgIface
//		mockedUsesOtherPkgIface := &MoqUsesOtherPkgIface{
//			DoSomethingElseFunc: func(obj Sibling)  {
//				panic("mock out the DoSomethingElse method")
//			},
//		}
//
//		// use mockedUsesOtherPkgIface in code that requires UsesOtherPkgIface
//		// and then make assertions.
//
//	}
type MoqUsesOtherPkgIface struct {
	// DoSomethingElseFunc mocks the DoSomethingElse method.
	DoSomethingElseFunc func(obj Sibling)

	// calls tracks calls to the methods.
	calls struct {
		// DoSomethingElse holds details about calls to the DoSomethingElse method.
		DoSomethingElse []struct {
			// Obj is the obj argument value.
			Obj Sibling
		}
	}
	lockDoSomethingElse sync.RWMutex
}

// DoSomethingElse calls DoSomethingElseFunc.
func (mock *MoqUsesOtherPkgIface) DoSomethingElse(obj Sibling) {
	callInfo := struct {
		Obj Sibling
	}{
		Obj: obj,
	}
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = append(mock.calls.DoSomethingElse, callInfo)
	mock.lockDoSomethingElse.Unlock()
	if mock.DoSomethingElseFunc == nil {
		return
	}
	mock.DoSomethingElseFunc(obj)
}

// DoSomethingElseCalls gets all the calls that were made to DoSomethingElse.
// Check the length with:
//
//	len(mockedUsesOtherPkgIface.DoSomethingElseCalls())
func (mock *MoqUsesOtherPkgIface) DoSomethingElseCalls() []struct {
	Obj Sibling
} {
	var calls []struct {
		Obj Sibling
	}
	mock.lockDoSomethingElse.RLock()
	calls = mock.calls.DoSomethingElse
	mock.lockDoSomethingElse.RUnlock()
	return calls
}

// ResetDoSomethingElseCalls reset all the calls that were made to DoSomethingElse.
func (mock *MoqUsesOtherPkgIface) ResetDoSomethingElseCalls() {
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = nil
	mock.lockDoSomethingElse.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqUsesOtherPkgIface) ResetCalls() {
	mock.lockDoSomethingElse.Lock()
	mock.calls.DoSomethingElse = nil
	mock.lockDoSomethingElse.Unlock()
}

// Ensure, that MoqPanicOnNoReturnValue does implement PanicOnNoReturnValue.
// If this is not the case, regenerate this file with moq.
var _ PanicOnNoReturnValue = &MoqPanicOnNoReturnValue{}

// MoqPanicOnNoReturnValue is a mock implementation of PanicOnNoReturnValue.
//
//	func TestSomethingThatUsesPanicOnNoReturnValue(t *testing.T) {
//
//		// make and configure a mocked PanicOnNoReturnValue
//		mockedPanicOnNoReturnValue := &MoqPanicOnNoReturnValue{
//			DoSomethingFunc: func() string {
//				panic("mock out the DoSomething method")
//			},
//		}
//
//		// use mockedPanicOnNoReturnValue in code that requires PanicOnNoReturnValue
//		// and then make assertions.
//
//	}
type MoqPanicOnNoReturnValue struct {
	// DoSomethingFunc mocks the DoSomething method.
	DoSomethingFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// DoSomething holds details about calls to the DoSomething method.
		DoSomething []struct {
		}
	}
	lockDoSomething sync.RWMutex
}

// DoSomething calls DoSomethingFunc.
func (mock *MoqPanicOnNoReturnValue) DoSomething() string {
	callInfo := struct {
	}{}
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = append(mock.calls.DoSomething, callInfo)
	mock.lockDoSomething.Unlock()
	if mock.DoSomethingFunc == nil {
		var (
			s string
		)
		return s
	}
	return mock.DoSomethingFunc()
}

// DoSomethingCalls gets all the calls that were made to DoSomething.
// Check the length with:
//
//	len(mockedPanicOnNoReturnValue.DoSomethingCalls())
func (mock *MoqPanicOnNoReturnValue) DoSomethingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDoSomething.RLock()
	calls = mock.calls.DoSomething
	mock.lockDoSomething.RUnlock()
	return calls
}

// ResetDoSomethingCalls reset all the calls that were made to DoSomething.
func (mock *MoqPanicOnNoReturnValue) ResetDoSomethingCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqPanicOnNoReturnValue) ResetCalls() {
	mock.lockDoSomething.Lock()
	mock.calls.DoSomething = nil
	mock.lockDoSomething.Unlock()
}

// MoqRequesterSkipEnsure is a mock implementation of Requester.
//
//	func TestSomethingThatUsesRequester(t *testing.T) {
//
//		// make and configure a mocked Requester
//		mockedRequester := &MoqRequesterSkipEnsure{
//			GetFunc: func(path string) (string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester in code that requires Requester
//		// and then make assertions.
//
//	}
type MoqRequesterSkipEnsure struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterSkipEnsure) Get(path string) (string, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			s   string
			err error
		)
		return s, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester.GetCalls())
func (mock *MoqRequesterSkipEnsure) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterSkipEnsure) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterSkipEnsure) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequester does implement Requester.
// If this is not the case, regenerate this file with moq.
var _ Requester = &MoqRequester{}

// MoqRequester is a mock implementation of Requester.
//
//	func TestSomethingThatUsesRequester(t *testing.T) {
//
//		// make and configure a mocked Requester
//		mockedRequester := &MoqRequester{
//			GetFunc: func(path string) (string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester in code that requires Requester
//		// and then make assertions.
//
//	}
type MoqRequester struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequester) Get(path string) (string, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			s   string
			err error
		)
		return s, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester.GetCalls())
func (mock *MoqRequester) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequester) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequester) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that StubMatyerRequester does implement Requester.
// If this is not the case, regenerate this file with moq.
var _ Requester = &StubMatyerRequester{}

// StubMatyerRequester is a mock implementation of Requester.
//
//	func TestSomethingThatUsesRequester(t *testing.T) {
//
//		// make and configure a mocked Requester
//		mockedRequester := &StubMatyerRequester{
//			GetFunc: func(path string) (string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester in code that requires Requester
//		// and then make assertions.
//
//	}
type StubMatyerRequester struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *StubMatyerRequester) Get(path string) (string, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			s   string
			err error
		)
		return s, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester.GetCalls())
func (mock *StubMatyerRequester) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *StubMatyerRequester) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *StubMatyerRequester) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequester2 does implement Requester2.
// If this is not the case, regenerate this file with moq.
var _ Requester2 = &MoqRequester2{}

// MoqRequester2 is a mock implementation of Requester2.
//
//	func TestSomethingThatUsesRequester2(t *testing.T) {
//
//		// make and configure a mocked Requester2
//		mockedRequester2 := &MoqRequester2{
//			GetFunc: func(path string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester2 in code that requires Requester2
//		// and then make assertions.
//
//	}
type MoqRequester2 struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequester2) Get(path string) error {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester2.GetCalls())
func (mock *MoqRequester2) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequester2) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequester2) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequester3 does implement Requester3.
// If this is not the case, regenerate this file with moq.
var _ Requester3 = &MoqRequester3{}

// MoqRequester3 is a mock implementation of Requester3.
//
//	func TestSomethingThatUsesRequester3(t *testing.T) {
//
//		// make and configure a mocked Requester3
//		mockedRequester3 := &MoqRequester3{
//			GetFunc: func() error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester3 in code that requires Requester3
//		// and then make assertions.
//
//	}
type MoqRequester3 struct {
	// GetFunc mocks the Get method.
	GetFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequester3) Get() error {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester3.GetCalls())
func (mock *MoqRequester3) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequester3) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequester3) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequester4 does implement Requester4.
// If this is not the case, regenerate this file with moq.
var _ Requester4 = &MoqRequester4{}

// MoqRequester4 is a mock implementation of Requester4.
//
//	func TestSomethingThatUsesRequester4(t *testing.T) {
//
//		// make and configure a mocked Requester4
//		mockedRequester4 := &MoqRequester4{
//			GetFunc: func()  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequester4 in code that requires Requester4
//		// and then make assertions.
//
//	}
type MoqRequester4 struct {
	// GetFunc mocks the Get method.
	GetFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequester4) Get() {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		return
	}
	mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequester4.GetCalls())
func (mock *MoqRequester4) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequester4) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequester4) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterArgSameAsImport does implement RequesterArgSameAsImport.
// If this is not the case, regenerate this file with moq.
var _ RequesterArgSameAsImport = &MoqRequesterArgSameAsImport{}

// MoqRequesterArgSameAsImport is a mock implementation of RequesterArgSameAsImport.
//
//	func TestSomethingThatUsesRequesterArgSameAsImport(t *testing.T) {
//
//		// make and configure a mocked RequesterArgSameAsImport
//		mockedRequesterArgSameAsImport := &MoqRequesterArgSameAsImport{
//			GetFunc: func(json1 string) *json.RawMessage {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsImport in code that requires RequesterArgSameAsImport
//		// and then make assertions.
//
//	}
type MoqRequesterArgSameAsImport struct {
	// GetFunc mocks the Get method.
	GetFunc func(json1 string) *json.RawMessage

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Json1 is the json1 argument value.
			Json1 string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterArgSameAsImport) Get(json1 string) *json.RawMessage {
	callInfo := struct {
		Json1 string
	}{
		Json1: json1,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			rawMessage *json.RawMessage
		)
		return rawMessage
	}
	return mock.GetFunc(json1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsImport.GetCalls())
func (mock *MoqRequesterArgSameAsImport) GetCalls() []struct {
	Json1 string
} {
	var calls []struct {
		Json1 string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterArgSameAsImport) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterArgSameAsImport) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterArgSameAsNamedImport does implement RequesterArgSameAsNamedImport.
// If this is not the case, regenerate this file with moq.
var _ RequesterArgSameAsNamedImport = &MoqRequesterArgSameAsNamedImport{}

// MoqRequesterArgSameAsNamedImport is a mock implementation of RequesterArgSameAsNamedImport.
//
//	func TestSomethingThatUsesRequesterArgSameAsNamedImport(t *testing.T) {
//
//		// make and configure a mocked RequesterArgSameAsNamedImport
//		mockedRequesterArgSameAsNamedImport := &MoqRequesterArgSameAsNamedImport{
//			GetFunc: func(json1 string) *json.RawMessage {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsNamedImport in code that requires RequesterArgSameAsNamedImport
//		// and then make assertions.
//
//	}
type MoqRequesterArgSameAsNamedImport struct {
	// GetFunc mocks the Get method.
	GetFunc func(json1 string) *json.RawMessage

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Json1 is the json1 argument value.
			Json1 string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterArgSameAsNamedImport) Get(json1 string) *json.RawMessage {
	callInfo := struct {
		Json1 string
	}{
		Json1: json1,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			rawMessage *json.RawMessage
		)
		return rawMessage
	}
	return mock.GetFunc(json1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsNamedImport.GetCalls())
func (mock *MoqRequesterArgSameAsNamedImport) GetCalls() []struct {
	Json1 string
} {
	var calls []struct {
		Json1 string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterArgSameAsNamedImport) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterArgSameAsNamedImport) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterArgSameAsPkg does implement RequesterArgSameAsPkg.
// If this is not the case, regenerate this file with moq.
var _ RequesterArgSameAsPkg = &MoqRequesterArgSameAsPkg{}

// MoqRequesterArgSameAsPkg is a mock implementation of RequesterArgSameAsPkg.
//
//	func TestSomethingThatUsesRequesterArgSameAsPkg(t *testing.T) {
//
//		// make and configure a mocked RequesterArgSameAsPkg
//		mockedRequesterArgSameAsPkg := &MoqRequesterArgSameAsPkg{
//			GetFunc: func(test1 string)  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArgSameAsPkg in code that requires RequesterArgSameAsPkg
//		// and then make assertions.
//
//	}
type MoqRequesterArgSameAsPkg struct {
	// GetFunc mocks the Get method.
	GetFunc func(test1 string)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Test1 is the test1 argument value.
			Test1 string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterArgSameAsPkg) Get(test1 string) {
	callInfo := struct {
		Test1 string
	}{
		Test1: test1,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		return
	}
	mock.GetFunc(test1)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArgSameAsPkg.GetCalls())
func (mock *MoqRequesterArgSameAsPkg) GetCalls() []struct {
	Test1 string
} {
	var calls []struct {
		Test1 string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterArgSameAsPkg) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterArgSameAsPkg) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterArray does implement RequesterArray.
// If this is not the case, regenerate this file with moq.
var _ RequesterArray = &MoqRequesterArray{}

// MoqRequesterArray is a mock implementation of RequesterArray.
//
//	func TestSomethingThatUsesRequesterArray(t *testing.T) {
//
//		// make and configure a mocked RequesterArray
//		mockedRequesterArray := &MoqRequesterArray{
//			GetFunc: func(path string) ([2]string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterArray in code that requires RequesterArray
//		// and then make assertions.
//
//	}
type MoqRequesterArray struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) ([2]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterArray) Get(path string) ([2]string, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			strings [2]string
			err     error
		)
		return strings, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterArray.GetCalls())
func (mock *MoqRequesterArray) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterArray) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterArray) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterElided does implement RequesterElided.
// If this is not the case, regenerate this file with moq.
var _ RequesterElided = &MoqRequesterElided{}

// MoqRequesterElided is a mock implementation of RequesterElided.
//
//	func TestSomethingThatUsesRequesterElided(t *testing.T) {
//
//		// make and configure a mocked RequesterElided
//		mockedRequesterElided := &MoqRequesterElided{
//			GetFunc: func(path string, url string) error {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterElided in code that requires RequesterElided
//		// and then make assertions.
//
//	}
type MoqRequesterElided struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string, url string) error

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
			// URL is the url argument value.
			URL string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterElided) Get(path string, url string) error {
	callInfo := struct {
		Path string
		URL  string
	}{
		Path: path,
		URL:  url,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.GetFunc(path, url)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterElided.GetCalls())
func (mock *MoqRequesterElided) GetCalls() []struct {
	Path string
	URL  string
} {
	var calls []struct {
		Path string
		URL  string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterElided) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterElided) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterIface does implement RequesterIface.
// If this is not the case, regenerate this file with moq.
var _ RequesterIface = &MoqRequesterIface{}

// MoqRequesterIface is a mock implementation of RequesterIface.
//
//	func TestSomethingThatUsesRequesterIface(t *testing.T) {
//
//		// make and configure a mocked RequesterIface
//		mockedRequesterIface := &MoqRequesterIface{
//			GetFunc: func() io.Reader {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterIface in code that requires RequesterIface
//		// and then make assertions.
//
//	}
type MoqRequesterIface struct {
	// GetFunc mocks the Get method.
	GetFunc func() io.Reader

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterIface) Get() io.Reader {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			reader io.Reader
		)
		return reader
	}
	return mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterIface.GetCalls())
func (mock *MoqRequesterIface) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterIface) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterIface) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterNS does implement RequesterNS.
// If this is not the case, regenerate this file with moq.
var _ RequesterNS = &MoqRequesterNS{}

// MoqRequesterNS is a mock implementation of RequesterNS.
//
//	func TestSomethingThatUsesRequesterNS(t *testing.T) {
//
//		// make and configure a mocked RequesterNS
//		mockedRequesterNS := &MoqRequesterNS{
//			GetFunc: func(path string) (http.Response, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterNS in code that requires RequesterNS
//		// and then make assertions.
//
//	}
type MoqRequesterNS struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (http.Response, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterNS) Get(path string) (http.Response, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			response http.Response
			err      error
		)
		return response, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterNS.GetCalls())
func (mock *MoqRequesterNS) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterNS) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterNS) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterPtr does implement RequesterPtr.
// If this is not the case, regenerate this file with moq.
var _ RequesterPtr = &MoqRequesterPtr{}

// MoqRequesterPtr is a mock implementation of RequesterPtr.
//
//	func TestSomethingThatUsesRequesterPtr(t *testing.T) {
//
//		// make and configure a mocked RequesterPtr
//		mockedRequesterPtr := &MoqRequesterPtr{
//			GetFunc: func(path string) (*string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterPtr in code that requires RequesterPtr
//		// and then make assertions.
//
//	}
type MoqRequesterPtr struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (*string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterPtr) Get(path string) (*string, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			s   *string
			err error
		)
		return s, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterPtr.GetCalls())
func (mock *MoqRequesterPtr) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterPtr) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterPtr) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterReturnElided does implement RequesterReturnElided.
// If this is not the case, regenerate this file with moq.
var _ RequesterReturnElided = &MoqRequesterReturnElided{}

// MoqRequesterReturnElided is a mock implementation of RequesterReturnElided.
//
//	func TestSomethingThatUsesRequesterReturnElided(t *testing.T) {
//
//		// make and configure a mocked RequesterReturnElided
//		mockedRequesterReturnElided := &MoqRequesterReturnElided{
//			GetFunc: func(path string) (int, int, int, error) {
//				panic("mock out the Get method")
//			},
//			PutFunc: func(path string) (int, error) {
//				panic("mock out the Put method")
//			},
//		}
//
//		// use mockedRequesterReturnElided in code that requires RequesterReturnElided
//		// and then make assertions.
//
//	}
type MoqRequesterReturnElided struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) (int, int, int, error)

	// PutFunc mocks the Put method.
	PutFunc func(path string) (int, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
		// Put holds details about calls to the Put method.
		Put []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
	lockPut sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterReturnElided) Get(path string) (int, int, int, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			a   int
			b   int
			c   int
			err error
		)
		return a, b, c, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterReturnElided.GetCalls())
func (mock *MoqRequesterReturnElided) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterReturnElided) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Put calls PutFunc.
func (mock *MoqRequesterReturnElided) Put(path string) (int, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockPut.Lock()
	mock.calls.Put = append(mock.calls.Put, callInfo)
	mock.lockPut.Unlock()
	if mock.PutFunc == nil {
		var (
			n   int
			err error
		)
		return n, err
	}
	return mock.PutFunc(path)
}

// PutCalls gets all the calls that were made to Put.
// Check the length with:
//
//	len(mockedRequesterReturnElided.PutCalls())
func (mock *MoqRequesterReturnElided) PutCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockPut.RLock()
	calls = mock.calls.Put
	mock.lockPut.RUnlock()
	return calls
}

// ResetPutCalls reset all the calls that were made to Put.
func (mock *MoqRequesterReturnElided) ResetPutCalls() {
	mock.lockPut.Lock()
	mock.calls.Put = nil
	mock.lockPut.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterReturnElided) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockPut.Lock()
	mock.calls.Put = nil
	mock.lockPut.Unlock()
}

// Ensure, that MoqRequesterSlice does implement RequesterSlice.
// If this is not the case, regenerate this file with moq.
var _ RequesterSlice = &MoqRequesterSlice{}

// MoqRequesterSlice is a mock implementation of RequesterSlice.
//
//	func TestSomethingThatUsesRequesterSlice(t *testing.T) {
//
//		// make and configure a mocked RequesterSlice
//		mockedRequesterSlice := &MoqRequesterSlice{
//			GetFunc: func(path string) ([]string, error) {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedRequesterSlice in code that requires RequesterSlice
//		// and then make assertions.
//
//	}
type MoqRequesterSlice struct {
	// GetFunc mocks the Get method.
	GetFunc func(path string) ([]string, error)

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Path is the path argument value.
			Path string
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterSlice) Get(path string) ([]string, error) {
	callInfo := struct {
		Path string
	}{
		Path: path,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			strings []string
			err     error
		)
		return strings, err
	}
	return mock.GetFunc(path)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterSlice.GetCalls())
func (mock *MoqRequesterSlice) GetCalls() []struct {
	Path string
} {
	var calls []struct {
		Path string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterSlice) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterSlice) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqrequesterUnexported does implement requesterUnexported.
// If this is not the case, regenerate this file with moq.
var _ requesterUnexported = &MoqrequesterUnexported{}

// MoqrequesterUnexported is a mock implementation of requesterUnexported.
//
//	func TestSomethingThatUsesrequesterUnexported(t *testing.T) {
//
//		// make and configure a mocked requesterUnexported
//		mockedrequesterUnexported := &MoqrequesterUnexported{
//			GetFunc: func()  {
//				panic("mock out the Get method")
//			},
//		}
//
//		// use mockedrequesterUnexported in code that requires requesterUnexported
//		// and then make assertions.
//
//	}
type MoqrequesterUnexported struct {
	// GetFunc mocks the Get method.
	GetFunc func()

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
		}
	}
	lockGet sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqrequesterUnexported) Get() {
	callInfo := struct {
	}{}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		return
	}
	mock.GetFunc()
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedrequesterUnexported.GetCalls())
func (mock *MoqrequesterUnexported) GetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqrequesterUnexported) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqrequesterUnexported) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// Ensure, that MoqRequesterVariadic does implement RequesterVariadic.
// If this is not the case, regenerate this file with moq.
var _ RequesterVariadic = &MoqRequesterVariadic{}

// MoqRequesterVariadic is a mock implementation of RequesterVariadic.
//
//	func TestSomethingThatUsesRequesterVariadic(t *testing.T) {
//
//		// make and configure a mocked RequesterVariadic
//		mockedRequesterVariadic := &MoqRequesterVariadic{
//			GetFunc: func(values ...string) bool {
//				panic("mock out the Get method")
//			},
//			MultiWriteToFileFunc: func(filename string, w ...io.Writer) string {
//				panic("mock out the MultiWriteToFile method")
//			},
//			OneInterfaceFunc: func(a ...interface{}) bool {
//				panic("mock out the OneInterface method")
//			},
//			SprintfFunc: func(format string, a ...interface{}) string {
//				panic("mock out the Sprintf method")
//			},
//		}
//
//		// use mockedRequesterVariadic in code that requires RequesterVariadic
//		// and then make assertions.
//
//	}
type MoqRequesterVariadic struct {
	// GetFunc mocks the Get method.
	GetFunc func(values ...string) bool

	// MultiWriteToFileFunc mocks the MultiWriteToFile method.
	MultiWriteToFileFunc func(filename string, w ...io.Writer) string

	// OneInterfaceFunc mocks the OneInterface method.
	OneInterfaceFunc func(a ...interface{}) bool

	// SprintfFunc mocks the Sprintf method.
	SprintfFunc func(format string, a ...interface{}) string

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Values is the values argument value.
			Values []string
		}
		// MultiWriteToFile holds details about calls to the MultiWriteToFile method.
		MultiWriteToFile []struct {
			// Filename is the filename argument value.
			Filename string
			// W is the w argument value.
			W []io.Writer
		}
		// OneInterface holds details about calls to the OneInterface method.
		OneInterface []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Sprintf holds details about calls to the Sprintf method.
		Sprintf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
	}
	lockGet              sync.RWMutex
	lockMultiWriteToFile sync.RWMutex
	lockOneInterface     sync.RWMutex
	lockSprintf          sync.RWMutex
}

// Get calls GetFunc.
func (mock *MoqRequesterVariadic) Get(values ...string) bool {
	callInfo := struct {
		Values []string
	}{
		Values: values,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	if mock.GetFunc == nil {
		var (
			b bool
		)
		return b
	}
	return mock.GetFunc(values...)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedRequesterVariadic.GetCalls())
func (mock *MoqRequesterVariadic) GetCalls() []struct {
	Values []string
} {
	var calls []struct {
		Values []string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// ResetGetCalls reset all the calls that were made to Get.
func (mock *MoqRequesterVariadic) ResetGetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()
}

// MultiWriteToFile calls MultiWriteToFileFunc.
func (mock *MoqRequesterVariadic) MultiWriteToFile(filename string, w ...io.Writer) string {
	callInfo := struct {
		Filename string
		W        []io.Writer
	}{
		Filename: filename,
		W:        w,
	}
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = append(mock.calls.MultiWriteToFile, callInfo)
	mock.lockMultiWriteToFile.Unlock()
	if mock.MultiWriteToFileFunc == nil {
		var (
			s string
		)
		return s
	}
	return mock.MultiWriteToFileFunc(filename, w...)
}

// MultiWriteToFileCalls gets all the calls that were made to MultiWriteToFile.
// Check the length with:
//
//	len(mockedRequesterVariadic.MultiWriteToFileCalls())
func (mock *MoqRequesterVariadic) MultiWriteToFileCalls() []struct {
	Filename string
	W        []io.Writer
} {
	var calls []struct {
		Filename string
		W        []io.Writer
	}
	mock.lockMultiWriteToFile.RLock()
	calls = mock.calls.MultiWriteToFile
	mock.lockMultiWriteToFile.RUnlock()
	return calls
}

// ResetMultiWriteToFileCalls reset all the calls that were made to MultiWriteToFile.
func (mock *MoqRequesterVariadic) ResetMultiWriteToFileCalls() {
	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()
}

// OneInterface calls OneInterfaceFunc.
func (mock *MoqRequesterVariadic) OneInterface(a ...interface{}) bool {
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = append(mock.calls.OneInterface, callInfo)
	mock.lockOneInterface.Unlock()
	if mock.OneInterfaceFunc == nil {
		var (
			b bool
		)
		return b
	}
	return mock.OneInterfaceFunc(a...)
}

// OneInterfaceCalls gets all the calls that were made to OneInterface.
// Check the length with:
//
//	len(mockedRequesterVariadic.OneInterfaceCalls())
func (mock *MoqRequesterVariadic) OneInterfaceCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockOneInterface.RLock()
	calls = mock.calls.OneInterface
	mock.lockOneInterface.RUnlock()
	return calls
}

// ResetOneInterfaceCalls reset all the calls that were made to OneInterface.
func (mock *MoqRequesterVariadic) ResetOneInterfaceCalls() {
	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()
}

// Sprintf calls SprintfFunc.
func (mock *MoqRequesterVariadic) Sprintf(format string, a ...interface{}) string {
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = append(mock.calls.Sprintf, callInfo)
	mock.lockSprintf.Unlock()
	if mock.SprintfFunc == nil {
		var (
			s string
		)
		return s
	}
	return mock.SprintfFunc(format, a...)
}

// SprintfCalls gets all the calls that were made to Sprintf.
// Check the length with:
//
//	len(mockedRequesterVariadic.SprintfCalls())
func (mock *MoqRequesterVariadic) SprintfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockSprintf.RLock()
	calls = mock.calls.Sprintf
	mock.lockSprintf.RUnlock()
	return calls
}

// ResetSprintfCalls reset all the calls that were made to Sprintf.
func (mock *MoqRequesterVariadic) ResetSprintfCalls() {
	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqRequesterVariadic) ResetCalls() {
	mock.lockGet.Lock()
	mock.calls.Get = nil
	mock.lockGet.Unlock()

	mock.lockMultiWriteToFile.Lock()
	mock.calls.MultiWriteToFile = nil
	mock.lockMultiWriteToFile.Unlock()

	mock.lockOneInterface.Lock()
	mock.calls.OneInterface = nil
	mock.lockOneInterface.Unlock()

	mock.lockSprintf.Lock()
	mock.calls.Sprintf = nil
	mock.lockSprintf.Unlock()
}

// Ensure, that MoqExample does implement Example.
// If this is not the case, regenerate this file with moq.
var _ Example = &MoqExample{}

// MoqExample is a mock implementation of Example.
//
//	func TestSomethingThatUsesExample(t *testing.T) {
//
//		// make and configure a mocked Example
//		mockedExample := &MoqExample{
//			AFunc: func() http.Flusher {
//				panic("mock out the A method")
//			},
//			BFunc: func(fixtureshttp string) http0.MyStruct {
//				panic("mock out the B method")
//			},
//			CFunc: func(fixtureshttp string) http1.MyStruct {
//				panic("mock out the C method")
//			},
//		}
//
//		// use mockedExample in code that requires Example
//		// and then make assertions.
//
//	}
type MoqExample struct {
	// AFunc mocks the A method.
	AFunc func() http.Flusher

	// BFunc mocks the B method.
	BFunc func(fixtureshttp string) http0.MyStruct

	// CFunc mocks the C method.
	CFunc func(fixtureshttp string) http1.MyStruct

	// calls tracks calls to the methods.
	calls struct {
		// A holds details about calls to the A method.
		A []struct {
		}
		// B holds details about calls to the B method.
		B []struct {
			// Fixtureshttp is the fixtureshttp argument value.
			Fixtureshttp string
		}
		// C holds details about calls to the C method.
		C []struct {
			// Fixtureshttp is the fixtureshttp argument value.
			Fixtureshttp string
		}
	}
	lockA sync.RWMutex
	lockB sync.RWMutex
	lockC sync.RWMutex
}

// A calls AFunc.
func (mock *MoqExample) A() http.Flusher {
	callInfo := struct {
	}{}
	mock.lockA.Lock()
	mock.calls.A = append(mock.calls.A, callInfo)
	mock.lockA.Unlock()
	if mock.AFunc == nil {
		var (
			flusher http.Flusher
		)
		return flusher
	}
	return mock.AFunc()
}

// ACalls gets all the calls that were made to A.
// Check the length with:
//
//	len(mockedExample.ACalls())
func (mock *MoqExample) ACalls() []struct {
} {
	var calls []struct {
	}
	mock.lockA.RLock()
	calls = mock.calls.A
	mock.lockA.RUnlock()
	return calls
}

// ResetACalls reset all the calls that were made to A.
func (mock *MoqExample) ResetACalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()
}

// B calls BFunc.
func (mock *MoqExample) B(fixtureshttp string) http0.MyStruct {
	callInfo := struct {
		Fixtureshttp string
	}{
		Fixtureshttp: fixtureshttp,
	}
	mock.lockB.Lock()
	mock.calls.B = append(mock.calls.B, callInfo)
	mock.lockB.Unlock()
	if mock.BFunc == nil {
		var (
			myStruct http0.MyStruct
		)
		return myStruct
	}
	return mock.BFunc(fixtureshttp)
}

// BCalls gets all the calls that were made to B.
// Check the length with:
//
//	len(mockedExample.BCalls())
func (mock *MoqExample) BCalls() []struct {
	Fixtureshttp string
} {
	var calls []struct {
		Fixtureshttp string
	}
	mock.lockB.RLock()
	calls = mock.calls.B
	mock.lockB.RUnlock()
	return calls
}

// ResetBCalls reset all the calls that were made to B.
func (mock *MoqExample) ResetBCalls() {
	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()
}

// C calls CFunc.
func (mock *MoqExample) C(fixtureshttp string) http1.MyStruct {
	callInfo := struct {
		Fixtureshttp string
	}{
		Fixtureshttp: fixtureshttp,
	}
	mock.lockC.Lock()
	mock.calls.C = append(mock.calls.C, callInfo)
	mock.lockC.Unlock()
	if mock.CFunc == nil {
		var (
			myStruct http1.MyStruct
		)
		return myStruct
	}
	return mock.CFunc(fixtureshttp)
}

// CCalls gets all the calls that were made to C.
// Check the length with:
//
//	len(mockedExample.CCalls())
func (mock *MoqExample) CCalls() []struct {
	Fixtureshttp string
} {
	var calls []struct {
		Fixtureshttp string
	}
	mock.lockC.RLock()
	calls = mock.calls.C
	mock.lockC.RUnlock()
	return calls
}

// ResetCCalls reset all the calls that were made to C.
func (mock *MoqExample) ResetCCalls() {
	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqExample) ResetCalls() {
	mock.lockA.Lock()
	mock.calls.A = nil
	mock.lockA.Unlock()

	mock.lockB.Lock()
	mock.calls.B = nil
	mock.lockB.Unlock()

	mock.lockC.Lock()
	mock.calls.C = nil
	mock.lockC.Unlock()
}

// Ensure, that MoqA does implement A.
// If this is not the case, regenerate this file with moq.
var _ A = &MoqA{}

// MoqA is a mock implementation of A.
//
//	func TestSomethingThatUsesA(t *testing.T) {
//
//		// make and configure a mocked A
//		mockedA := &MoqA{
//			CallFunc: func() (B, error) {
//				panic("mock out the Call method")
//			},
//		}
//
//		// use mockedA in code that requires A
//		// and then make assertions.
//
//	}
type MoqA struct {
	// CallFunc mocks the Call method.
	CallFunc func() (B, error)

	// calls tracks calls to the methods.
	calls struct {
		// Call holds details about calls to the Call method.
		Call []struct {
		}
	}
	lockCall sync.RWMutex
}

// Call calls CallFunc.
func (mock *MoqA) Call() (B, error) {
	callInfo := struct {
	}{}
	mock.lockCall.Lock()
	mock.calls.Call = append(mock.calls.Call, callInfo)
	mock.lockCall.Unlock()
	if mock.CallFunc == nil {
		var (
			b   B
			err error
		)
		return b, err
	}
	return mock.CallFunc()
}

// CallCalls gets all the calls that were made to Call.
// Check the length with:
//
//	len(mockedA.CallCalls())
func (mock *MoqA) CallCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCall.RLock()
	calls = mock.calls.Call
	mock.lockCall.RUnlock()
	return calls
}

// ResetCallCalls reset all the calls that were made to Call.
func (mock *MoqA) ResetCallCalls() {
	mock.lockCall.Lock()
	mock.calls.Call = nil
	mock.lockCall.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqA) ResetCalls() {
	mock.lockCall.Lock()
	mock.calls.Call = nil
	mock.lockCall.Unlock()
}

// Ensure, that MoqStructWithTag does implement StructWithTag.
// If this is not the case, regenerate this file with moq.
var _ StructWithTag = &MoqStructWithTag{}

// MoqStructWithTag is a mock implementation of StructWithTag.
//
//	func TestSomethingThatUsesStructWithTag(t *testing.T) {
//
//		// make and configure a mocked StructWithTag
//		mockedStructWithTag := &MoqStructWithTag{
//			MethodAFunc: func(v *struct{FieldA int "json:\"field_a\""; FieldB int "json:\"field_b\" xml:\"field_b\""}) *struct{FieldC int "json:\"field_c\""; FieldD int "json:\"field_d\" xml:\"field_d\""} {
//				panic("mock out the MethodA method")
//			},
//		}
//
//		// use mockedStructWithTag in code that requires StructWithTag
//		// and then make assertions.
//
//	}
type MoqStructWithTag struct {
	// MethodAFunc mocks the MethodA method.
	MethodAFunc func(v *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}) *struct {
		FieldC int "json:\"field_c\""
		FieldD int "json:\"field_d\" xml:\"field_d\""
	}

	// calls tracks calls to the methods.
	calls struct {
		// MethodA holds details about calls to the MethodA method.
		MethodA []struct {
			// V is the v argument value.
			V *struct {
				FieldA int "json:\"field_a\""
				FieldB int "json:\"field_b\" xml:\"field_b\""
			}
		}
	}
	lockMethodA sync.RWMutex
}

// MethodA calls MethodAFunc.
func (mock *MoqStructWithTag) MethodA(v *struct {
	FieldA int "json:\"field_a\""
	FieldB int "json:\"field_b\" xml:\"field_b\""
}) *struct {
	FieldC int "json:\"field_c\""
	FieldD int "json:\"field_d\" xml:\"field_d\""
} {
	callInfo := struct {
		V *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}{
		V: v,
	}
	mock.lockMethodA.Lock()
	mock.calls.MethodA = append(mock.calls.MethodA, callInfo)
	mock.lockMethodA.Unlock()
	if mock.MethodAFunc == nil {
		var (
			val *struct {
				FieldC int "json:\"field_c\""
				FieldD int "json:\"field_d\" xml:\"field_d\""
			}
		)
		return val
	}
	return mock.MethodAFunc(v)
}

// MethodACalls gets all the calls that were made to MethodA.
// Check the length with:
//
//	len(mockedStructWithTag.MethodACalls())
func (mock *MoqStructWithTag) MethodACalls() []struct {
	V *struct {
		FieldA int "json:\"field_a\""
		FieldB int "json:\"field_b\" xml:\"field_b\""
	}
} {
	var calls []struct {
		V *struct {
			FieldA int "json:\"field_a\""
			FieldB int "json:\"field_b\" xml:\"field_b\""
		}
	}
	mock.lockMethodA.RLock()
	calls = mock.calls.MethodA
	mock.lockMethodA.RUnlock()
	return calls
}

// ResetMethodACalls reset all the calls that were made to MethodA.
func (mock *MoqStructWithTag) ResetMethodACalls() {
	mock.lockMethodA.Lock()
	mock.calls.MethodA = nil
	mock.lockMethodA.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqStructWithTag) ResetCalls() {
	mock.lockMethodA.Lock()
	mock.calls.MethodA = nil
	mock.lockMethodA.Unlock()
}

// Ensure, that MoqUnsafeInterface does implement UnsafeInterface.
// If this is not the case, regenerate this file with moq.
var _ UnsafeInterface = &MoqUnsafeInterface{}

// MoqUnsafeInterface is a mock implementation of UnsafeInterface.
//
//	func TestSomethingThatUsesUnsafeInterface(t *testing.T) {
//
//		// make and configure a mocked UnsafeInterface
//		mockedUnsafeInterface := &MoqUnsafeInterface{
//			DoFunc: func(ptr *unsafe.Pointer)  {
//				panic("mock out the Do method")
//			},
//		}
//
//		// use mockedUnsafeInterface in code that requires UnsafeInterface
//		// and then make assertions.
//
//	}
type MoqUnsafeInterface struct {
	// DoFunc mocks the Do method.
	DoFunc func(ptr *unsafe.Pointer)

	// calls tracks calls to the methods.
	calls struct {
		// Do holds details about calls to the Do method.
		Do []struct {
			// Ptr is the ptr argument value.
			Ptr *unsafe.Pointer
		}
	}
	lockDo sync.RWMutex
}

// Do calls DoFunc.
func (mock *MoqUnsafeInterface) Do(ptr *unsafe.Pointer) {
	callInfo := struct {
		Ptr *unsafe.Pointer
	}{
		Ptr: ptr,
	}
	mock.lockDo.Lock()
	mock.calls.Do = append(mock.calls.Do, callInfo)
	mock.lockDo.Unlock()
	if mock.DoFunc == nil {
		return
	}
	mock.DoFunc(ptr)
}

// DoCalls gets all the calls that were made to Do.
// Check the length with:
//
//	len(mockedUnsafeInterface.DoCalls())
func (mock *MoqUnsafeInterface) DoCalls() []struct {
	Ptr *unsafe.Pointer
} {
	var calls []struct {
		Ptr *unsafe.Pointer
	}
	mock.lockDo.RLock()
	calls = mock.calls.Do
	mock.lockDo.RUnlock()
	return calls
}

// ResetDoCalls reset all the calls that were made to Do.
func (mock *MoqUnsafeInterface) ResetDoCalls() {
	mock.lockDo.Lock()
	mock.calls.Do = nil
	mock.lockDo.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqUnsafeInterface) ResetCalls() {
	mock.lockDo.Lock()
	mock.calls.Do = nil
	mock.lockDo.Unlock()
}

// Ensure, that MoqVariadic does implement Variadic.
// If this is not the case, regenerate this file with moq.
var _ Variadic = &MoqVariadic{}

// MoqVariadic is a mock implementation of Variadic.
//
//	func TestSomethingThatUsesVariadic(t *testing.T) {
//
//		// make and configure a mocked Variadic
//		mockedVariadic := &MoqVariadic{
//			VariadicFunctionFunc: func(str string, vFunc VariadicFunction) error {
//				panic("mock out the VariadicFunction method")
//			},
//		}
//
//		// use mockedVariadic in code that requires Variadic
//		// and then make assertions.
//
//	}
type MoqVariadic struct {
	// VariadicFunctionFunc mocks the VariadicFunction method.
	VariadicFunctionFunc func(str string, vFunc VariadicFunction) error

	// calls tracks calls to the methods.
	calls struct {
		// VariadicFunction holds details about calls to the VariadicFunction method.
		VariadicFunction []struct {
			// Str is the str argument value.
			Str string
			// VFunc is the vFunc argument value.
			VFunc VariadicFunction
		}
	}
	lockVariadicFunction sync.RWMutex
}

// VariadicFunction calls VariadicFunctionFunc.
func (mock *MoqVariadic) VariadicFunction(str string, vFunc VariadicFunction) error {
	callInfo := struct {
		Str   string
		VFunc VariadicFunction
	}{
		Str:   str,
		VFunc: vFunc,
	}
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = append(mock.calls.VariadicFunction, callInfo)
	mock.lockVariadicFunction.Unlock()
	if mock.VariadicFunctionFunc == nil {
		var (
			err error
		)
		return err
	}
	return mock.VariadicFunctionFunc(str, vFunc)
}

// VariadicFunctionCalls gets all the calls that were made to VariadicFunction.
// Check the length with:
//
//	len(mockedVariadic.VariadicFunctionCalls())
func (mock *MoqVariadic) VariadicFunctionCalls() []struct {
	Str   string
	VFunc VariadicFunction
} {
	var calls []struct {
		Str   string
		VFunc VariadicFunction
	}
	mock.lockVariadicFunction.RLock()
	calls = mock.calls.VariadicFunction
	mock.lockVariadicFunction.RUnlock()
	return calls
}

// ResetVariadicFunctionCalls reset all the calls that were made to VariadicFunction.
func (mock *MoqVariadic) ResetVariadicFunctionCalls() {
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = nil
	mock.lockVariadicFunction.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqVariadic) ResetCalls() {
	mock.lockVariadicFunction.Lock()
	mock.calls.VariadicFunction = nil
	mock.lockVariadicFunction.Unlock()
}

// Ensure, that MoqVariadicReturnFunc does implement VariadicReturnFunc.
// If this is not the case, regenerate this file with moq.
var _ VariadicReturnFunc = &MoqVariadicReturnFunc{}

// MoqVariadicReturnFunc is a mock implementation of VariadicReturnFunc.
//
//	func TestSomethingThatUsesVariadicReturnFunc(t *testing.T) {
//
//		// make and configure a mocked VariadicReturnFunc
//		mockedVariadicReturnFunc := &MoqVariadicReturnFunc{
//			SampleMethodFunc: func(str string) func(str string, arr []int, a ...interface{}) {
//				panic("mock out the SampleMethod method")
//			},
//		}
//
//		// use mockedVariadicReturnFunc in code that requires VariadicReturnFunc
//		// and then make assertions.
//
//	}
type MoqVariadicReturnFunc struct {
	// SampleMethodFunc mocks the SampleMethod method.
	SampleMethodFunc func(str string) func(str string, arr []int, a ...interface{})

	// calls tracks calls to the methods.
	calls struct {
		// SampleMethod holds details about calls to the SampleMethod method.
		SampleMethod []struct {
			// Str is the str argument value.
			Str string
		}
	}
	lockSampleMethod sync.RWMutex
}

// SampleMethod calls SampleMethodFunc.
func (mock *MoqVariadicReturnFunc) SampleMethod(str string) func(str string, arr []int, a ...interface{}) {
	callInfo := struct {
		Str string
	}{
		Str: str,
	}
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = append(mock.calls.SampleMethod, callInfo)
	mock.lockSampleMethod.Unlock()
	if mock.SampleMethodFunc == nil {
		var (
			fn func(str string, arr []int, a ...interface{})
		)
		return fn
	}
	return mock.SampleMethodFunc(str)
}

// SampleMethodCalls gets all the calls that were made to SampleMethod.
// Check the length with:
//
//	len(mockedVariadicReturnFunc.SampleMethodCalls())
func (mock *MoqVariadicReturnFunc) SampleMethodCalls() []struct {
	Str string
} {
	var calls []struct {
		Str string
	}
	mock.lockSampleMethod.RLock()
	calls = mock.calls.SampleMethod
	mock.lockSampleMethod.RUnlock()
	return calls
}

// ResetSampleMethodCalls reset all the calls that were made to SampleMethod.
func (mock *MoqVariadicReturnFunc) ResetSampleMethodCalls() {
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = nil
	mock.lockSampleMethod.Unlock()
}

// ResetCalls reset all the calls that were made to all mocked methods.
func (mock *MoqVariadicReturnFunc) ResetCalls() {
	mock.lockSampleMethod.Lock()
	mock.calls.SampleMethod = nil
	mock.lockSampleMethod.Unlock()
}
