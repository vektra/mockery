{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"mockery","text":"<p>v3 Migration Docs</p> <p>Beta Test</p> <p>Mockery <code>v3</code> is currently in beta and should not be used for production.</p> <p>Mockery is a project that creates mock implementations of Golang interfaces. It inspects source code and generates implementations of the interface that aid in testing.</p> <p>In addition to providing a number of different styles of mocks, mockery also allows users to provide their own template files that will then be rendered using a set of template data, methods, and functions that provide comprehensive typing information about the Go interface in question.</p> <p> </p>"},{"location":"#why-mockery","title":"Why mockery?","text":"<p>When you have an interface like this:</p> db.go<pre><code>type DB interface {\n    Get(val string) string\n}\n</code></pre> <p>and a function that takes this interface:</p> db_getter.go<pre><code>func getFromDB(db DB) string {\n    return db.Get(\"ice cream\")\n}\n</code></pre> <p>We can use simple configuration to generate a mock implementation for the interface:</p> .mockery.yaml<pre><code>packages:\n    github.com/org/repo:\n        interfaces:\n            DB:\n</code></pre> Bash<pre><code>$ mockery\n05 Mar 23 21:49 CST INF Starting mockery dry-run=false version=v3.0.0\n05 Mar 23 21:49 CST INF Using config: .mockery.yaml dry-run=false version=v3.0.0\n05 Mar 23 21:49 CST INF Generating mock dry-run=false interface=DB qualified-name=github.com/org/repo version=v3.0.0\n</code></pre> <p>We can then use the mock object in a test:</p> db_getter_test.go<pre><code>import (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_getFromDB(t *testing.T) {\n    mockDB := NewMockDB(t)\n    mockDB.EXPECT().Get(\"ice cream\").Return(\"chocolate\").Once()\n    flavor := getFromDB(mockDB)\n    assert.Equal(t, \"chocolate\", flavor)\n}\n</code></pre>"},{"location":"#why-use-mockery","title":"Why use mockery?","text":"<ol> <li>You gain access to a number of pre-curated mock implementations that can be used in testing. This includes traditional \"mockery-style\" mocks, as well as other styles from the open source community such as from https://github.com/matryer/moq. Such mocks allow you to quickly define how the implementation should behave under test without having to manually curate your own mocks/stubs/fakes.</li> <li>Mockery benefits from a large number of performance improvements that almost all other Go code-generation projects currently have not employed. This means that it's orders of magnitude faster for large codebases.</li> <li>Mockery provides a comprehensive, centralized, flexible, and simple configuration scheme driven off of yaml instead of relying on sprawling <code>//go:generate</code> commands.</li> <li>Mockery is a code-generation framework. While its original goal is to provide mock implementations for testing purposes, users can supply their own templates to auto-generate any kind of code that needs to be based off of interfaces.</li> <li>A number of high profile companies, projects, and communities trust Mockery.</li> </ol>"},{"location":"#who-uses-mockery","title":"Who uses mockery?","text":"<ul> <li> Kubernetes </li> <li> Grafana </li> <li> Google skia </li> <li> Google syzkaller </li> <li> Hashicorp </li> <li> Jaegertracing </li> <li> Splunk kafka-mq-go </li> <li> </li> <li> </li> <li> </li> <li></li> <li> eksctl </li> <li> </li> <li> Task <li> <p>Get Started</p>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#mockery-init","title":"<code>mockery init</code>","text":"<p><code>mockery init [module_name]</code> is a useful command that can bootstrap you with a fully-functioning configuration set. For example, if we run:</p> <pre><code>$ mockery init github.com/vektra/mockery/v3/internal/fixtures\n2025-03-14T23:06:12.535709000-05:00 INF writing to file file=.mockery.yml version=v0.0.0-dev\n2025-03-14T23:06:12.536493000-05:00 INF done version=v0.0.0-dev\n</code></pre> .mockery.yml<pre><code>all: false\ndir: '{{.InterfaceDir}}'\nfilename: mocks_test.go\nforce-file-write: false\nformatter: goimports\nlog-level: info\nstructname: Mock{{.InterfaceName}}\npkgname: '{{.SrcPackageName}}'\nrecursive: false\ntemplate: testify\npackages:\n  github.com/vektra/mockery/v3/internal/fixtures:\n    config:\n      all: true\n</code></pre> <p>We can then run mockery against this config to generate the code:</p> <pre><code>$ mockery\n2025-03-14T23:42:17.014113000-05:00 INF Starting mockery config-file=/Users/landon/git/LandonTClipp/mockery/.mockery.yaml version=v0.0.0-dev\n2025-03-14T23:42:17.014258000-05:00 INF Parsing configured packages... version=v0.0.0-dev\n2025-03-14T23:42:17.527483000-05:00 INF Done parsing configured packages. version=v0.0.0-dev\n[...]\n2025-03-14T23:42:17.531239000-05:00 INF Executing template file=/Users/landon/git/LandonTClipp/mockery/internal/fixtures/mocks_test.go version=v0.0.0-dev\n2025-03-14T23:42:17.690601000-05:00 INF Writing template to file file=/Users/landon/git/LandonTClipp/mockery/internal/fixtures/mocks_test.go version=v0.0.0-dev\n</code></pre> <pre><code>$ head -n 17 /Users/landon/git/LandonTClipp/mockery/internal/fixtures/mocks_test.go\n// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n        \"encoding/json\"\n        \"io\"\n        \"net/http\"\n        \"unsafe\"\n\n        mock \"github.com/stretchr/testify/mock\"\n        http1 \"github.com/vektra/mockery/v3/internal/fixtures/12345678/http\"\n        \"github.com/vektra/mockery/v3/internal/fixtures/constraints\"\n        http0 \"github.com/vektra/mockery/v3/internal/fixtures/http\"\n        test \"github.com/vektra/mockery/v3/internal/fixtures/redefined_type_b\"\n)\n</code></pre> Extended Example <p>A more complex configuration example can be seen below:</p> YAML<pre><code>all: False\ntemplate-data:\n  boilerplate-file: ./path/to/boilerplate.txt\ntemplate: testify\npackages:\n  github.com/vektra/example:\n    config:\n      # Make use of the template variables to place the mock in the same\n      # directory as the original interface.\n      dir: \"{{.InterfaceDir}}\"\n      filename: \"mocks_test.go\"\n      outpkg: \"{{.PackageName}}_test\"\n      structname: \"Mock{{.InterfaceName}}\"\n    interfaces:\n      Foo:\n      Bar:\n        config:\n          # Make it unexported instead\n          structname: \"mock{{.InterfaceName}}\"\n      Baz:\n        # Create two mock implementations of Baz with different names.\n        configs:\n          - filename: \"mocks_baz_one_test.go\"\n            structname: \"MockBazOne\"\n          - filename: \"mocks_baz_two_test.go\"\n            structname: \"MockBazTwo\"\n  io:\n    config:\n      dir: path/to/io/mocks\n      filename: \"mocks_io.go\"\n</code></pre> <p>These are the highlights of the config scheme:</p> <ol> <li>The parameters are merged hierarchically</li> <li>There are a number of template variables available to generalize config values.</li> <li>The style of mock to be generated is specified using the <code>template</code> parameter.</li> </ol>"},{"location":"configuration/#parameter-descriptions","title":"Parameter Descriptions","text":"name templated default description <code>all</code> <code>false</code> Generate all interfaces for the specified packages. <code>_anchors</code> <code>{}</code> Unused by mockery, but allowed in the config schema so that you may define arbitrary yaml anchors. <code>config</code> <code>\"\"</code> Set the location of the mockery config file. <code>dir</code> <code>\"mocks/{{.SrcPackagePath}}\"</code> The directory where the mock file will be outputted to. <code>exclude-subpkg-regex</code> <code>[]</code> A list of regular expressions that denote which subpackages should be excluded when <code>recursive: true</code> <code>exclude-regex</code> <code>\"\"</code> When set along with <code>include-regex</code>, then interfaces which match <code>include-regex</code> but also match <code>exclude-regex</code> will not be generated. If <code>all</code> is set, or if <code>include-regex</code> is not set, then <code>exclude-regex</code> has no effect. <code>filename</code> <code>\"mock_{{.InterfaceName}}.go\"</code> The name of the file the mock will reside in. <code>force-file-write</code> <code>false</code> When set to <code>force-file-write: true</code>, mockery will forcibly overwrite any existing files. <code>formatter</code> <code>\"goimports\"</code> The formatter to use on the rendered template. Choices are: <code>gofmt</code>, <code>goimports</code>, <code>noop</code>. <code>include-regex</code> <code>\"\"</code> When set, only interface names that match the expression will be generated. This setting is ignored if <code>all: True</code> is specified in the configuration. To further refine the interfaces generated, use <code>exclude-regex</code>. <code>log-level</code> <code>\"info\"</code> Set the level of the logger <code>structname</code> <code>\"Mock{{.InterfaceName}}\"</code> The name of the generated interface implementation. <code>packages</code> <code>null</code> A dictionary containing configuration describing the packages and interfaces to generate mocks for. <code>pkgname</code> <code>\"{{.SrcPackageName}}\"</code> The <code>package name</code> given to the generated mock files. <code>recursive</code> <code>false</code> When set to <code>true</code> on a particular package, mockery will recursively search for all sub-packages and inject those packages into the config map. <code>replace-type</code> <code>{}</code> Use this parameter to specify type replacements. <code>build-tags</code> <code>\"\"</code> A space-separated list of additional build tags to load packages. <code>template</code> <code>\"\"</code> The template to use. The choices are <code>moq</code>, <code>mockery</code>, or a file path provided by <code>file://path/to/file.txt</code>. <code>template-data</code> <code>{}</code> A <code>map[string]any</code> that provides arbitrary options to the template. Each template will have a different set of accepted keys. Refer to each template's documentation for more details. <code>template-schema</code> <code>\"{{.Template}}.schema.json\"</code> The URL of the JSON schema to apply to the <code>template-data</code> parameter. See the template docs for more details. <p><code>pkg.go.dev</code></p> <p>The full schema definition can be viewed at our pkg.go.dev site.</p>"},{"location":"configuration/#templates","title":"Templates","text":"<p>Parameters marked as being templated have access to a number of template variables and functions through the Go <code>text/template</code> system.</p>"},{"location":"configuration/#variables","title":"Variables","text":"<p>The variables provided are specified in the <code>config.Data</code> struct.</p>"},{"location":"configuration/#functions","title":"Functions","text":"<p>All of the functions defined in <code>StringManipulationFuncs</code> are available to templated parameters.</p>"},{"location":"configuration/#config-sources","title":"Config sources","text":"<p>Config can not only be specified from the <code>.yml</code> file, but also from CLI parameters (where available) and environment variables. For example, specifying a boolean value for a particular parameter called <code>enable-feature</code> from each config source would look like this:</p> source value command line <code>--enable-feature=true</code> Environment variable <code>MOCKERY_ENABLE_FEATURE=True</code> yaml <code>enable-feature: True</code> <p>Config is loaded from each source in the following order:</p> <ol> <li>Default values</li> <li>Environment variables</li> <li>Config file</li> <li>CLI Parameters</li> </ol>"},{"location":"dev-notes/","title":"Developer Notes","text":""},{"location":"dev-notes/#go-upgrades","title":"Go Upgrades","text":"<p>The mockery project supports the most recent TWO stable Go versions. Testing matrices will only run on the two most recent stable Go versions. However, given the Go backwards-compatibility guarantee, it's very likely projects built off of older Go 1.x syntax will continue to work in perpetuity.(1)</p> <ol> <li> <p>The caveat, being noted, is the same as the above linked backwards compatibility guarantee:</p> <p>There are a few qualifications to that. First, compatibility means source compatibility. When you update to a new version of Go, you do have to recompile your code. Second, we can add new APIs, but not in a way that breaks existing code.</p> <p>The end of the document warns, \u201c[It] is impossible to guarantee that no future change will break any program.\u201d Then it lays out a number of reasons why programs might still break.</p> <p>For example, it makes sense that if your program depends on a buggy behavior and we fix the bug, your program will break. But we try very hard to break as little as possible and keep Go boring. There are two main approaches we\u2019ve used so far: API checking and testing.</p> </li> </ol>"},{"location":"dev-notes/#go-syntax-updates","title":"Go Syntax Updates","text":"<p>When Go releases new syntax, there are two approaches that the mockery project will take:</p>"},{"location":"dev-notes/#mockery-does-not-need-to-interact-with-the-new-syntax","title":"Mockery does not need to interact with the new syntax","text":"<p>In such cases, the mockery project only needs to upgrade its <code>golang.org/x/tools</code> dependency. This is necessary for the parsing step to simply not fail if it encounters new syntax. If mockery does not need to interact or understand this syntax, this dependency upgrade is likely all that's needed.</p> <p>Take for example the problems mentioned [here] when mockery upgraded to <code>go 1.24</code> in its <code>go.mod</code> file. In this situation, the project maintainers wanted to allow mockery to not crash when it parses syntax containing generic type alias syntax. However, the project did not parse this syntax, so the only thing we needed to do was upgrade <code>golang.org/x/tools</code>.</p>"},{"location":"dev-notes/#mockery-does-need-to-interact-with-the-new-syntax","title":"Mockery does need to interact with the new syntax","text":"<p>This situation was encountered in Go 1.18 when generics were introduced. In this case, the project needed to be upgraded to <code>go 1.18</code> because mockery now had to directly parse and interpret generic types through the <code>go/ast</code> package. This was needed in conjunction with an upgrade of <code>golang.org/x/tools</code> that handles the actual parsing into <code>go/ast</code> data.</p> <p>It's possible in future versions of Go that only the <code>toolchain</code> directive needs to be upgraded to allow mockery to use a more recent <code>go/ast</code> package. The purposes of the <code>go</code> directive is supposed to inform the compiler what features of the Go language the module uses in its own syntax, so in this case as long as mockery does not itself use generics, it can parse generic type information from other projects without needing to pin its <code>go</code> directive to the relevant version.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#error-no-go-files-found-in-root-search-path","title":"error: <code>no go files found in root search path</code>","text":"<p>When using the <code>packages</code> feature, <code>recursive: true</code> and you have specified a package that contains no <code>*.go</code> files, mockery is unable to determine the on-disk location of the package in order to continue the recursive package search. This appears to be a limitation of the golang.org/x/tools/go/packages package that is used to parse package metadata.</p> <p>The solution is to create a <code>.go</code> file in the package's path and add a <code>package [name]</code> directive at the top. It doesn't matter what the file is called. This allows mockery to properly read package metadata.</p> <p>Discussion</p>"},{"location":"faq/#internal-error-package-without-types-was-imported","title":"internal error: package without types was imported","text":"<p>https://github.com/vektra/mockery/issues/475</p> <p>This issue indicates that you have attempted to use package in your dependency tree (whether direct or indirect) that uses Go language semantics that your currently-running Go version does not support. The solution:</p> <ol> <li>Update to the latest go version</li> <li>Delete all cached packages with <code>go clean -modcache</code></li> <li>Reinstall mockery</li> </ol> <p>Additionally, this issue only happens when compiling mockery from source, such as with <code>go install</code>. Our docs recommend not to use <code>go install</code> as the success of your build depends on the compatibility of your Go version with the semantics in use. You would not encounter this issue if using one of the installation methods that install pre-built binaries, like downloading the <code>.tar.gz</code> binaries, or through <code>brew install</code>.</p>"},{"location":"faq/#semantic-versioning","title":"Semantic Versioning","text":"<p>The mockery project follows the standard Semantic Versioning Semantics. The versioning applies to the following areas:</p> <ol> <li>The shape of mocks generated by pre-curated templates.</li> <li>Functions and data provided to templates specified with <code>template: \"file://\"</code>.</li> <li>Configuration options.</li> </ol> <p>Mockery is not meant to be used as an imported library. Importing mockery code in external modules is not supported.</p>"},{"location":"faq/#mocking-interfaces-in-main","title":"Mocking interfaces in <code>main</code>","text":"<p>When your interfaces are in the main package, you should supply the <code>--inpackage</code> flag. This will generate mocks in the same package as the target code, avoiding import issues.</p>"},{"location":"faq/#mockery-fails-to-run-when-mockery_version-environment-variable-is-set","title":"mockery fails to run when <code>MOCKERY_VERSION</code> environment variable is set","text":"<p>This issue was first highlighted in this GitHub issue.</p> <p>mockery uses the viper package for configuration mapping and parsing. Viper is set to automatically search for all config variables specified in its config struct. One of the config variables is named <code>version</code>, which gets mapped to an environment variable called <code>MOCKERY_VERSION</code>. If you set this environment variable, mockery attempts to parse it into the <code>version</code> bool config.</p> <p>This is an adverse effect of how our config parsing is set up. The solution is to rename your environment variable to something other than <code>MOCKERY_VERSION</code>.</p>"},{"location":"installation/","title":"Getting Started","text":""},{"location":"installation/#installation","title":"Installation","text":""},{"location":"installation/#github-release-recommended","title":"GitHub Release recommended","text":"<p>Visit the releases page to download one of the pre-built binaries for your platform.</p>"},{"location":"installation/#go-install","title":"go install","text":"<p>Supported, but not recommended: see wiki page and related discussions.</p> <p>Warning</p> <p>Do not use <code>@latest</code> as this will pull from the latest, potentially untagged, commit on master.</p>"},{"location":"installation/#docker","title":"Docker","text":"<p>Use the Docker image</p> Text Only<pre><code>docker pull vektra/mockery\n</code></pre> <p>Generate all the mocks for your project:</p> Text Only<pre><code>docker run -v \"$PWD\":/src -w /src vektra/mockery --all\n</code></pre>"},{"location":"installation/#homebrew","title":"Homebrew","text":"<p>Install through brew</p> Text Only<pre><code>brew install mockery\nbrew upgrade mockery\n</code></pre>"},{"location":"replace-type/","title":"replace-type","text":"<p>The <code>replace-type:</code> parameter allows you to replace a type in the generated mocks with another type. Take for example the following interface:</p> interface.go<pre><code>package replace_type\n\nimport (\n    \"github.com/vektra/mockery/v3/internal/fixtures/example_project/replace_type/rti/rt1\"\n    \"github.com/vektra/mockery/v3/internal/fixtures/example_project/replace_type/rti/rt2\"\n)\n\ntype RType interface {\n    Replace1(f rt1.RType1)\n}\n</code></pre> <p>You can selectively replace the <code>rt1.RType1</code> with a new type if so desired. For example:</p>"},{"location":"replace-type/#schema","title":"Schema","text":".mockery.yml<pre><code>replace-type:\n  github.com/vektra/mockery/v3/internal/fixtures/example_project/replace_type/rti/rt1:\n    RType1:\n      pkg-path: github.com/vektra/mockery/v3/internal/fixtures/example_project/replace_type/rti/rt2\n      type-name: RType2\n</code></pre>"},{"location":"replace-type/#result","title":"Result","text":"<p>The mock will now replace all instances of <code>rt1.RType1</code> with <code>rt2.RType2</code>. You can see the before and after of <code>mockery</code>-style mocks:</p> beforeafter Go<pre><code>// Replace2 provides a mock function for the type RTypeReplaced1\nfunc (_mock *RTypeReplaced1) Replace1(f rt1.RType1) {\n    _mock.Called(f)\n    return\n}\n</code></pre> Go<pre><code>// Replace2 provides a mock function for the type RTypeReplaced1\nfunc (_mock *RTypeReplaced1) Replace1(f rt2.RType2) {\n    _mock.Called(f)\n    return\n}\n</code></pre>"},{"location":"replace-type/#background","title":"Background","text":"<p>This parameter is useful if you need to need to work around packages that use internal types. Take for example the situation found here, noted by RangelReale.</p>"},{"location":"running/","title":"Running","text":"<p>If your <code>.mockery.yaml</code> file has been populated with the packages and interfaces you want mocked, mockery can be run with no arguments. Take for example how the mockery project itself is configured:</p> YAML<pre><code>quiet: False\nkeeptree: True\ndisable-version-string: True\nwith-expecter: True\nstructname: \"{{.InterfaceName}}\"\nfilename: \"{{.StructName}}.go\"\noutpkg: mocks\npackages:\n  github.com/vektra/mockery/v3/pkg:\n    interfaces:\n      TypesPackage:\n# Lots more config...\n</code></pre> <p>From anywhere within your repo, you can simply call <code>mockery</code> once, and it will find your config either by respecting the <code>config</code> path you gave it, or by searching upwards from the current working directory.</p> Bash<pre><code>mockery\n08 Jul 23 01:40 EDT INF Starting mockery dry-run=false version=v2.31.0\n08 Jul 23 01:40 EDT INF Using config: /Users/landonclipp/git/LandonTClipp/mockery/.mockery.yaml dry-run=false version=v2.31.0\n</code></pre> <p>Command line arguments</p> <p>It is valid to specify arguments from the command line. The configuration precedence is specified in the Configuration docs.</p>"},{"location":"v3/","title":"v3 Migration","text":"<p>Mockery releases version 3 of the project that provides a number of high-profile benefits over v2:</p> <ol> <li>Allows generation of <code>matryer</code>-style templates. The https://github.com/matryer/moq project is being subsumed into mockery to combine the speed and configuration flexibility of mockery with the simplicity of moq-style mocks.</li> <li>Changes the generation scheme to be entirely driven off of Go templates. This means that the data provided to templates is considered as part of the public API.</li> <li>Mockery now allows users to specify their own templates to make code generation far easier. Mockery handles the problem of parsing source code and enables you to focus on creating your own interface implementations.</li> <li>Shedding all deprecated variables and simplifying the way in which mocks are configured.</li> </ol>"},{"location":"v3/#mockery-migrate","title":"<code>mockery migrate</code>","text":"<p>A tool is provided that will migrate your v2 config to v3 on a best-effort basis. Take for example a v2 schema config:</p> <pre><code>quiet: False\ndisable-version-string: True\nwith-expecter: True\nstructname: \"{{.InterfaceNameCamel}}\"\nfilename: \"{{.StructName}}_mock.go\"\noutpkg: mocks\ntags: \"custom2\"\nissue-845-fix: True\nresolve-type-alias: False\npackages:\n  github.com/vektra/mockery/v2/pkg/fixtures:\n    config:\n      all: True\n    interfaces:\n      RequesterVariadic:\n        config:\n          with-expecter: False\n        configs:\n          - structname: RequesterVariadicOneArgument\n            unroll-variadic: False\n          - structname: RequesterVariadic\n            unroll-variadic: True\n      ReplaceGeneric:\n        config:\n          replace-type:\n            - github.com/vektra/mockery/v2/pkg/fixtures.ReplaceGeneric[-TImport]=github.com/vektra/mockery/v2/pkg/fixtures/redefined_type_b.B\n            - github.com/vektra/mockery/v2/pkg/fixtures.ReplaceGeneric[TConstraint]=github.com/vektra/mockery/v2/pkg/fixtures/constraints.String\n</code></pre> <p>We can run the command to migrate this to the v3 schema:</p> <pre><code>$ mockery migrate --config ./.mockery_v2.yml\n2025-03-28T00:26:44.762164000-05:00 INF using config config=./.mockery_v2.yml version=v0.0.0-dev\n2025-03-28T00:26:44.762804000-05:00 INF writing v3 config config=./.mockery_v2.yml v3-config=.mockery_v3.yml version=v0.0.0-dev\n2025-03-28T00:26:44.762914000-05:00 WRN breaking changes detected that possibly require manual intervention. See table below. config=./.mockery_v2.yml version=v0.0.0-dev\n</code></pre> <p>This command will return two results:</p> <code>.mockery_v3.yml</code>Deprecation Table <p>The translated v3 config file.</p> YAML<pre><code>structname: '{{.InterfaceNameCamel}}'\npkgname: mocks\ntemplate: testify\ntemplate-data:\n  with-expecter: true\npackages:\n  github.com/vektra/mockery/v2/pkg/fixtures:\n    config:\n      all: true\n    interfaces:\n      ReplaceGeneric:\n        config: {}\n      RequesterVariadic:\n        config:\n          template-data:\n            with-expecter: false\n        configs:\n          - structname: RequesterVariadicOneArgument\n            template-data:\n              unroll-variadic: false\n          - structname: RequesterVariadic\n            template-data:\n              unroll-variadic: true\n</code></pre> <p>A deprecation table that highlights situations that could not be resolved automatically. Each of these entries must be manually handled.</p> <p>Take for example the last entry mentioning <code>replace-type</code>. In v3, the schema for <code>replace-type</code> was changed from a parsed string to a more explicit key-value mapping.</p> <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502                                                              Deprecations                                                              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 IDX  DEPRECATION TYPE      MESSAGE                                                                                                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 0    template-variable     InterfaceNameCamel template variable has been deleted. Use \"{{ .InterfaceName | camelcase }}\" instead       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 1    deprecated-parameter  `tags` is no longer supported, parameter not migrated. Use `mock-build-tags` instead.                       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2    deprecated-parameter  `disable-func-mocks` permanently enabled in v3.                                                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 3    deprecated-parameter  `fail-on-missing` is permanently set to True in v3.                                                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 4    deprecated-parameter  `disable-version-string` is permanently set to True in v3.                                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 5    deprecated-parameter  `issue-845-fix` is permanently set to true in v3.                                                           \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 6    deprecated-parameter  `replace-type` has moved to a new schema. Cannot automatically migrate. Please visit                        \u2502\n\u2502                            https://vektra.github.io/mockery/latest-v3/replace-type/ for more information.                              \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>Warning</p> <p><code>mockery migrate</code> is not comprehensive and likely has missing edge cases. We encourage you to submit issues and PRs for any problems you encounter.</p>"},{"location":"v3/#layouts","title":"Layouts","text":"<p>In v2, mockery defaulted to placing mocks in a separate <code>mocks/</code> directory as shown here. In v3, mockery will by default place mocks adjacent to the mocked interface.</p> <p>It is still possible to place mocks in a separate directory by making use of the template variables and functions available to the configuration parameters.</p>"},{"location":"v3/#function-mocks","title":"Function Mocks","text":"<p>Mockery v2 allowed generating mocks for function types. v3 no longer does this as it provided little benefit for users.</p>"},{"location":"v3/#parameters","title":"Parameters","text":""},{"location":"v3/#inpackage-true","title":"<code>inpackage: True</code>","text":"<p>Mockery v2 has an <code>inpackage</code> parameter that informed mockery when a mock was being generated in the same package as the original interface. In v3, this parameter has been removed as mockery is now able to detect when the mock is placed in the same package.</p>"},{"location":"v3/#keeptree-true","title":"<code>keeptree: True</code>","text":"<p>Mockery v2 provided a <code>keeptree</code> parameter that was deprecated and used only in the pre-<code>packages</code> config schema. This parameter has no use in v3 and has been removed.</p>"},{"location":"v3/#replace-type","title":"<code>replace-type:</code>","text":"<p>The <code>replace-type:</code> parameter has an updated schema. In v2, users provided a list of strings, where each string needed to confirm to a specific format that was parsed at runtime. In v3, the schema is more explicit to make it simpler.</p>"},{"location":"v3/#structname","title":"<code>structname:</code>","text":"<p>The <code>structname</code> parameter has been replaced with <code>structname</code>.</p>"},{"location":"v3/#resolve-type-alias","title":"<code>resolve-type-alias:</code>","text":"<p>In v2, <code>resolve-type-alias</code> was set to <code>True</code> by default to retain backwards compatibility. In v3, this is permanently set to <code>False</code>.</p>"},{"location":"v3/#with-expecter","title":"<code>with-expecter:</code>","text":"<p>In v3, this parameter has been removed. <code>testify</code>-style mocks will always generate expecter methods.</p>"},{"location":"v3/#unroll-variadic","title":"<code>unroll-variadic:</code>","text":"<p>This parameter has been moved under the <code>template-data:</code> parameter. Parameters that apply only to specific templates are not expressed in the top-level schema and are instead passed through the schemaless <code>template-data:</code> map.</p>"},{"location":"v3/#exclude","title":"<code>exclude:</code>","text":"<p>This parameter in v2 was renamed to <code>exclude-subpkg-regex:</code>.</p>"},{"location":"v3/#v2-support-lifecycle","title":"v2 Support Lifecycle","text":"<p>In order to give the community ample time to adjust to v3, the mockery maintainers will support v2 until Dec 31, 2029 in the following ways:</p> <ol> <li>Bug fixes</li> <li>Security/vulnerability fixes</li> <li>Dependency updates to support future Go language versions.<sup>1</sup></li> </ol> <p>From the date at which v3 is released for full production, the Mockery project will support feature updates to v2 for a period of 6 months.</p> <ol> <li> <p>More specifically, we agree to update our dependencies used in parsing Go types such that Mockery is capable of parsing new syntax introduced in the Go language. The mockery project will not support changes to the generated code in a manner that makes use of any new language features. The only promise is that Mockery will be able to parse modules that use such new syntax or other language features without failing.\u00a0\u21a9</p> </li> </ol>"},{"location":"template/","title":"Templates","text":"<p>Mockery, in its essence, renders templates. This project provides a number of pre-curated templates that you can select with the <code>template:</code> config parameter.</p>"},{"location":"template/#template-options","title":"Template Options","text":""},{"location":"template/#template-testify","title":"<code>template: \"testify\"</code>","text":"<p><code>testify</code> templates generate powerful, testify-based mock objects. They allow you to create expectations using argument-to-return-value matching logic.</p>"},{"location":"template/#template-matryer","title":"<code>template: \"matryer\"</code>","text":"<p><code>matryer</code> templates draw from the mocks generated from the project at https://github.com/matryer/moq. This project was folded into mockery, and thus moq-style mocks can be natively generated from within mockery.</p> <p>Mocks generated using this template allow you to define precise functions to be run. Example:</p>"},{"location":"template/#template-file","title":"<code>template: \"file://</code>","text":"<p>You may also provide mockery a path to your own file using the <code>file://</code> protocol specifier. The string after <code>file://</code> will be the relative or absolute path of your template.</p> <p>The templates are rendered with the data as shown in the section below.</p> <p>You can see examples of how the mockery project utilizes the template system to generate the different mock styles:</p> <ul> <li><code>matryer.templ</code></li> <li><code>testify.templ</code></li> </ul>"},{"location":"template/#schemas","title":"Schemas","text":"<p>Templates can provide a JSON Schema file that describes the format of the <code>TemplateData</code> parameter. Mockery auto-discovers the location of these schema files by appending <code>.schema.json</code> to the path of the template. For example, if you provide to mockery <code>template: file://./path/to/template.tmpl</code>, it will look for a file at <code>file://./path/to/template.tmpl.schema.json</code>. If found, this schema will be applied to the <code>TemplateData</code> type sent to the template.</p> <p>To get started with JSON Schema, you can borrow an example JSON document used for the mockery project itself:</p> schema.json<pre><code>{\n    \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n    \"title\": \"vektra/mockery testify mock\",\n    \"type\": \"object\",\n    \"additionalProperties\": false,\n    \"properties\": {\n      \"boilerplate-file\": {\n        \"type\": \"string\"\n      },\n      \"mock-build-tags\": {\n        \"type\": \"string\"\n      },\n      \"unroll-variadic\": {\n        \"type\": \"boolean\"\n      }\n    },\n    \"required\": []\n}\n</code></pre> <p>Note that the <code>\"additionalProperties\": false</code> parameter is crucial to ensure only the specified parameters exist in the configured <code>template-data: {}</code> map.</p> <p><code>template-schema</code></p> <p>You can specify a custom schema path using the <code>template-schema:</code>parameter.</p>"},{"location":"template/#template-data","title":"Template Data","text":"<p>Templates are rendered with functions and data you can utilize to generate your mocks. Links are shown below:</p> Description Link Functions <code>template_funcs.FuncMap</code> Data <code>template.Data</code>"},{"location":"template/matryer/","title":"matryer/moq","text":""},{"location":"template/matryer/#description","title":"Description","text":"InterfaceExample Usage<code>.mockery.yml</code><code>mocks_moq.go</code> Go<pre><code>package test\n\ntype Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre> Go<pre><code>func TestRequesterMoq(t *testing.T) {\n    m := &amp;MoqRequester{\n        GetFunc: func(path string) (string, error) {\n            fmt.Printf(\"Go path: %s\\n\", path)\n            return path + \"/foo\", nil\n        },\n    }\n    result, err := m.Get(\"/path\")\n    assert.NoError(t, err)\n    assert.Equal(t, \"/path/foo\", result)\n}\n</code></pre> YAML<pre><code>template: matryer\npackages:\n    github.com/vektra/mockery/v3/pkg/fixtures:\n        config:\n            dir: \"{{.InterfaceDir}}\"\n            filename: \"mocks_moq.go\"\n            pkgname: \"test\"\n            structname: \"Moq{{.InterfaceName}}\"\n        interfaces:\n            Requester:\n</code></pre> Go<pre><code>// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n    \"sync\"\n)\n\n// Ensure, that MoqRequester does implement Requester.\n// If this is not the case, regenerate this file with moq.\nvar _ Requester = &amp;MoqRequester{}\n\n// MoqRequester is a mock implementation of Requester.\n//\n//  func TestSomethingThatUsesRequester(t *testing.T) {\n//\n//      // make and configure a mocked Requester\n//      mockedRequester := &amp;MoqRequester{\n//          GetFunc: func(path string) (string, error) {\n//              panic(\"mock out the Get method\")\n//          },\n//      }\n//\n//      // use mockedRequester in code that requires Requester\n//      // and then make assertions.\n//\n//  }\ntype MoqRequester struct {\n    // GetFunc mocks the Get method.\n    GetFunc func(path string) (string, error)\n\n    // calls tracks calls to the methods.\n    calls struct {\n        // Get holds details about calls to the Get method.\n        Get []struct {\n            // Path is the path argument value.\n            Path string\n        }\n    }\n    lockGet sync.RWMutex\n}\n\n// Get calls GetFunc.\nfunc (mock *MoqRequester) Get(path string) (string, error) {\n   // ...\n}\n\n// GetCalls gets all the calls that were made to Get.\n// Check the length with:\n//\n//  len(mockedRequester.GetCalls())\nfunc (mock *MoqRequester) GetCalls() []struct {\n    Path string\n} {\n    // ...\n}\n</code></pre> <p>Moq-style mocks are far simpler, and probably more intuitive, than testify-style mocks. All that's needed is to define the function that will be run when the mock's method is called.</p>"},{"location":"template/matryer/#template-data","title":"<code>template-data</code>","text":"<p><code>moq</code> accepts the following <code>template-data:</code> keys:</p> key type description <code>boilerplate-file</code> <code>string</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>mock-build-tags</code> <code>\"\"</code> Set the build tags of the generated mocks. Read more about the format. <code>skip-ensure</code> <code>bool</code> Suppress mock implementation check, avoid import cycle if mocks generated outside of the tested package. <code>stub-impl</code> <code>bool</code> Return zero values when no mock implementation is provided, do not panic. <code>with-resets</code> <code>bool</code> Generates methods that allow resetting calls made to the mocks."},{"location":"template/testify/","title":"Mockery","text":"<p>Features for <code>template: testify</code>.</p> <p>Choosing this template will render a traditional \"mockery-style\" template. The section below shows what will be rendered for the given interface.</p>"},{"location":"template/testify/#description","title":"Description","text":"InterfaceExample Usage<code>.mockery.yml</code><code>mocks.go</code> Go<pre><code>package test\n\ntype Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre> Go<pre><code>package test\n\nimport (\n    \"testing\"\n\n    \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestRequesterMock(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(\"foo\").Return(\"bar\", nil).Once()\n    retString, err := m.Get(\"foo\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"bar\")\n}\n</code></pre> YAML<pre><code>template: testify\npackages:\n    github.com/vektra/mockery/v3/pkg/fixtures:\n        config:\n            dir: \"{{.InterfaceDir}}\"\n            filename: \"mocks.go\"\n            pkgname: \"test\"\n            structname: \"Mock{{.InterfaceName}}\"\n        interfaces:\n            Requester:\n</code></pre> Go<pre><code>// Code generated by mockery; DO NOT EDIT.\n// github.com/vektra/mockery\n\npackage test\n\nimport (\n    mock \"github.com/stretchr/testify/mock\"\n)\n\n\n// NewRequester creates a new instance of Requester. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.\n// The first argument is typically a *testing.T value.\nfunc NewRequester (t interface {\n    mock.TestingT\n    Cleanup(func())\n}) *Requester {\n   // ...\n}\n\n\n// Requester is an autogenerated mock type for the Requester type\ntype Requester struct {\n    mock.Mock\n}\n\ntype Requester_Expecter struct {\n    mock *mock.Mock\n}\n\nfunc (_m *Requester) EXPECT() *Requester_Expecter {\n    // ...\n}\n\n\n\n// Get provides a mock function for the type Requester\nfunc (_mock *Requester) Get(path string) (string, error) {\n    // ...\n}\n\n\n\n// Requester_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'\ntype Requester_Get_Call struct {\n    *mock.Call\n}\n\n\n\n// Get is a helper method to define mock.On call\n//  - path\nfunc (_e *Requester_Expecter) Get(path interface{}, ) *Requester_Get_Call {\n    // ...\n}\n\nfunc (_c *Requester_Get_Call) Run(run func(path string)) *Requester_Get_Call {\n   // ...\n}\n\nfunc (_c *Requester_Get_Call) Return(s string, err error) *Requester_Get_Call {\n    // ...\n}\n\nfunc (_c *Requester_Get_Call) RunAndReturn(run func(path string)(string, error)) *Requester_Get_Call {\n    // ...\n}\n</code></pre> <p>As you can see, this mock utilizes <code>github.com/stretchr/testify</code> under the hood and registers call expectations with testify. When the mock receives a call to <code>Get()</code>, it retrieves the expected value from testify to be returned.</p> <p>This style of mock also has other interesting methods:</p> <code>Run()</code><code>RunAndReturn()</code><code>github.com/stretchr/testify/mock.Mock</code> <p>Run a side effect when the argument matches.</p> Go<pre><code>func TestRequesterMockRun(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).Return(\"\", nil)\n    m.EXPECT().Get(mock.Anything).Run(func(path string) {\n        fmt.Printf(\"Side effect! Argument is: %s\", path)\n    })\n    retString, err := m.Get(\"hello\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"\")\n}\n</code></pre> <p>Run a function to perform side-effects, and return the result of the function.</p> Go<pre><code>func TestRequesterMockRunAndReturn(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).RunAndReturn(func(path string) (string, error) {\n        return path + \" world\", nil\n    })\n    retString, err := m.Get(\"hello\")\n    assert.NoError(t, err)\n    assert.Equal(t, retString, \"hello world\")\n}\n</code></pre> <p>Because the mock embeds the testify <code>Mock</code> object, you can all any methods on that as well.</p> Go<pre><code>func TestRequesterMockTestifyEmbed(t *testing.T) {\n    m := NewMockRequester(t)\n    m.EXPECT().Get(mock.Anything).Return(\"\", nil).Twice()\n    m.Get(\"hello\")\n    m.Get(\"world\")\n    assert.Equal(t, len(m.Mock.Calls), 2)\n}\n</code></pre>"},{"location":"template/testify/#template-data","title":"<code>template-data</code>","text":"key type description <code>boilerplate-file</code> <code>string</code> Specify a path to a file that contains comments you want displayed at the top of all generated mock files. This is commonly used to display license headers at the top of your source code. <code>mock-build-tags</code> <code>\"\"</code> Set the build tags of the generated mocks. Read more about the format. <code>unroll-variadic</code> <code>bool</code> If set to <code>unroll-variadic: true</code>, will expand the variadic argument to testify using the <code>...</code> syntax. See notes for more details."},{"location":"template/testify/#features","title":"Features","text":""},{"location":"template/testify/#mock-constructors","title":"Mock Constructors","text":"<p> v2.11.0</p> <p>All mock objects have constructor functions. These constructors do basic test setup so that the expectations you set in the code are asserted before the test exits.</p> <p>Previously something like this would need to be done: Go<pre><code>factory := &amp;mocks.Factory{}\nfactory.Test(t) // so that mock does not panic when a method is unexpected\ndefer factory.AssertExpectations(t)\n</code></pre></p> <p>Instead, you may simply use the constructor: Go<pre><code>factory := mocks.NewFactory(t)\n</code></pre></p> <p>The constructor sets up common functionalities automatically</p> <ul> <li>The <code>AssertExpectations</code> method is registered to be called at the end of the tests via <code>t.Cleanup()</code> method.</li> <li>The testing.TB interface is registered on the <code>mock.Mock</code> so that tests don't panic when a call on the mock is unexpected.</li> </ul>"},{"location":"template/testify/#expecter-structs","title":"Expecter Structs","text":"<p> v2.10.0 \u00b7 <code>with-expecter: True</code></p> <p>Mockery now supports an \"expecter\" struct, which allows your tests to use type-safe methods to generate call expectations. When enabled through the <code>with-expecter: True</code> mockery configuration, you can enter into the expecter interface by simply calling <code>.EXPECT()</code> on your mock object.</p> <p>For example, given an interface such as Go<pre><code>type Requester interface {\n    Get(path string) (string, error)\n}\n</code></pre></p> <p>You can use the expecter interface as such: Go<pre><code>requesterMock := mocks.NewRequester(t)\nrequesterMock.EXPECT().Get(\"some path\").Return(\"result\", nil)\n</code></pre></p> <p>A <code>RunAndReturn</code> method is also available on the expecter struct that allows you to dynamically set a return value based on the input to the mock's call.</p> Go<pre><code>requesterMock.EXPECT().\n    Get(mock.Anything).\n    RunAndReturn(func(path string) (string, error) {\n        fmt.Println(path, \"was called\")\n        return (\"result for \" + path), nil\n    })\n</code></pre> <p>Note</p> <p>Note that the types of the arguments on the <code>EXPECT</code> methods are <code>interface{}</code>, not the actual type of your interface. The reason for this is that you may want to pass <code>mock.Any</code> as an argument, which means that the argument you pass may be an arbitrary type. The types are still provided in the expecter method docstrings.</p>"},{"location":"template/testify/#return-value-providers","title":"Return Value Providers","text":"<p> v2.20.0</p> <p>Return Value Providers can be used one of two ways. You may either define a single function with the exact same signature (number and type of input and return parameters) and pass that as a single value to <code>Return</code>, or you may pass multiple values to <code>Return</code> (one for each return parameter of the mocked function.)  If you are using the second form, for each of the return values of the mocked function, <code>Return</code> needs a function which takes the same arguments as the mocked function, and returns one of the return values. For example, if the return argument signature of <code>passthrough</code> in the above example was instead <code>(string, error)</code> in the interface, <code>Return</code> would also need a second function argument to define the error value:</p> Go<pre><code>type Proxy interface {\n    passthrough(ctx context.Context, s string) (string, error)\n}\n</code></pre> <p>First form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) (string, error) {\n        return s, nil\n    }\n)\n</code></pre> <p>Second form:</p> Go<pre><code>proxyMock := mocks.NewProxy(t)\nproxyMock.On(\"passthrough\", mock.AnythingOfType(\"context.Context\"), mock.AnythingOfType(\"string\")).\nReturn(\n    func(ctx context.Context, s string) string {\n        return s\n    },\n    func(ctx context.Context, s string) error {\n        return nil\n    },\n)\n</code></pre>"},{"location":"template/testify/#notes","title":"Notes","text":""},{"location":"template/testify/#variadic-arguments","title":"Variadic Arguments","text":"<p>Consider if we have a function <code>func Bar(message ...string) error</code>. A typical assertion might look like this:</p> Go<pre><code>func TestFoo(t *testing.T) {\n  m := NewMockFoo(t)\n  m.On(\"Bar\", \"hello\", \"world\").Return(nil)\n</code></pre> <p>We might also want to make an assertion that says \"any number of variadic arguments\":</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>However, what we've given to mockery is ambiguous because it is impossible to distinguish between these two intentions:</p> <ol> <li>Any number of variadic arguments of any value</li> <li>A single variadic argument of any value</li> </ol> <p>This is fixed in #359 where you can provide <code>unroll-variadic: False</code> to get back to the old behavior. Thus, if you want to assert (1), you can then do:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>If you want to assert (2), you must set <code>unroll-variadic: True</code>. Then this assertion's intention will be modified to mean the second case:</p> Go<pre><code>m.On(\"Bar\", mock.Anything).Return(nil)\n</code></pre> <p>An upstream patch to <code>testify</code> is currently underway to allow passing <code>mock.Anything</code> directly to the variadic slice: https://github.com/stretchr/testify/pull/1348</p> <p>If this is merged, it would become possible to describe the above two cases respectively:</p> Go<pre><code>// case 1\nm.On(\"Bar\", mock.Anything).Return(nil)\n// case 2\nm.On(\"Bar\", []interface{}{mock.Anything}).Return(nil)\n</code></pre> <p>References:</p> <ul> <li>https://github.com/vektra/mockery/pull/359</li> <li>https://github.com/vektra/mockery/pull/123</li> <li>https://github.com/vektra/mockery/pull/550</li> <li>https://github.com/vektra/mockery/issues/541</li> </ul>"},{"location":"template/testify/#multiple-expectations-with-identical-arguments","title":"Multiple Expectations With Identical Arguments","text":"<p>There might be instances where you want a mock to return different values on successive calls that provide the same arguments. For example, we might want to test this behavior:</p> Go<pre><code>// Return \"foo\" on the first call\ngetter := NewGetter()\nassert(t, \"foo\", getter.Get(\"key\"))\n\n// Return \"bar\" on the second call\nassert(t, \"bar\", getter.Get(\"key\"))\n</code></pre> <p>This can be done by using the <code>.Once()</code> method on the mock call expectation:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Once()\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Once()\n</code></pre> <p>Or you can identify an arbitrary number of times each value should be returned:</p> Go<pre><code>mockGetter := NewMockGetter(t)\nmockGetter.EXPECT().Get(mock.anything).Return(\"foo\").Times(4)\nmockGetter.EXPECT().Get(mock.anything).Return(\"bar\").Times(2)\n</code></pre> <p>Note that with proper Go support in your IDE, all the available methods are self-documented in autocompletion help contexts.</p>"}]}