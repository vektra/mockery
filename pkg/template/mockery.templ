{{ .Boilerplate }}
// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
{{- if .BuildTags }}

//go:build {{ .BuildTags }}
{{- end }}

package {{.PkgName}}

import (
{{- range .Imports}}
	{{. | ImportStatement}}
{{- end}}
    mock "github.com/stretchr/testify/mock"
)

{{/* CREATE CONSTRUCTOR */}}

{{- range $i, $mock := .Mocks }} {{/* START MOCK RANGE */}}
// New{{ .MockName }} creates a new instance of {{ .MockName }}. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func New{{ .MockName }}{{ $mock | TypeConstraint }} (t interface {
	mock.TestingT
	Cleanup(func())
}) *{{ .MockName }}{{ $mock | TypeInstantiation }} {
	mock := &{{ .MockName }}{{ $mock | TypeInstantiation }}{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}


// {{ .MockName }} is an autogenerated mock type for the {{ .InterfaceName }} type
type {{ .MockName }}{{ $mock | TypeConstraint }} struct {
	mock.Mock
}

type {{.MockName}}_Expecter{{ $mock | TypeConstraint }} struct {
	mock *mock.Mock
}

{{- $expecterNameInstantiated := printf "%s_Expecter%s" .MockName ($mock | TypeInstantiation) }}

func (_m *{{.MockName}}{{ $mock | TypeInstantiation }}) EXPECT() *{{ $expecterNameInstantiated }} {
	return &{{ $expecterNameInstantiated }}{mock: &_m.Mock}
}

{{/* RANGE OVER ALL METHODS */}}
{{- range $methodIdx, $method := .Methods }} {{/* START METHOD RANGE */}}

// {{ $method.Name }} provides a mock function for the type {{ $mock.MockName }}
func (_mock *{{$mock.MockName}}{{ $mock | TypeInstantiation }}) {{$method.Name}}({{$method.ArgList}}) {{$method.ReturnArgTypeList}} {
	{{- $calledString := "" }}
{{- if or
	(eq (len $method.ArgList) 0)
	(not $method.IsVariadic)
	(not (index $mock.TemplateData "unroll-variadic"))
}} {{/* START PREAMBLE */}}
	{{- if and
		($method.IsVariadic)
		(not (index $mock.TemplateData "unroll-variadic"))
	}}

	{{- if ne (len $method.Returns) 0}}
	var tmpRet mock.Arguments
	{{- $calledString = "tmpRet" }}
	{{- else }}
	{{- $calledString = "" }}
	{{- end }}

	{{- $lastParam := index $method.Params (len $method.Params | Add -1 )}}
	if len({{ $lastParam.Var.Name }}) > 0 {
		{{- if ne (len $method.Returns) 0}}tmpRet = {{ end }}_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	} else {
		{{- if ne (len $method.Returns) 0}}tmpRet = {{ end }}_mock.Called({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallListSlice 0 (len $method.Params | Add -1 )}}{{- else }}{{ $method.ArgCallListSliceNoEllipsis 0 (len $method.Params | Add -1 )}}{{- end }})
	}
	{{- else }}
	{{- $calledString = printf "_mock.Called(%s)" $method.ArgCallList }}
	{{- end }}
{{- else }}
	{{- $lastParam := (index $method.Params (len $method.Params | Add -1)) }}
	{{- $variadicArgsName := $lastParam.Var.Name }}
	{{- $strippedTypeString := TrimPrefix "..." $lastParam.TypeStringEllipsis }}

	{{- if and (ne $strippedTypeString "interface{}") (ne $strippedTypeString "any") }}
	// {{ $strippedTypeString }}
	_va := make([]interface{}, len({{- $lastParam.Var.Name }}))
	for _i := range {{ $lastParam.Var.Name }} {
		_va[_i] = {{ $lastParam.Var.Name }}[_i]
	}
		{{- $variadicArgsName = "_va" }}
	{{- end }}
	var _ca []interface{}
	{{- if gt (len $method.Params) 1 }}
	_ca = append(_ca, {{ $method.ArgCallListSlice 0 (len $method.Params | Add -1) }})
	{{- end }}
	_ca = append(_ca, {{ $variadicArgsName }}...)
	{{- $calledString = "_mock.Called(_ca...)" }}
{{- end }} {{/* END PREAMBLE */}}
	{{- if eq (len $method.Returns) 0 }}
	{{- $calledString }}
	{{- else }}
	ret := {{ $calledString }}

	if len(ret) == 0 {
		panic("no return value specified for {{$method.Name}}")
	}

		{{ range $retIdx, $ret := $method.Returns }}
	var r{{ $retIdx }} {{ (index $method.Returns $retIdx).TypeString }}
		{{- end }}

		{{- if gt (len $method.Returns) 1 }}
	if returnFunc, ok := ret.Get(0).(func({{ $method.ArgTypeList }}) {{ $method.ReturnArgTypeList }}); ok {
		return returnFunc({{- if (index $mock.TemplateData "unroll-variadic") }}{{ $method.ArgCallList }}{{- else }}{{ $method.ArgCallListNoEllipsis }}{{- end }})
	}
		{{- end }}

		{{- range $retIdx, $ret := $method.Returns }} {{/* START RETURN RANGE */}}
	if returnFunc, ok := ret.Get({{ $retIdx }}).(func({{$method.ArgTypeListEllipsis }}) {{ (index $method.Returns $retIdx).TypeString }}); ok {
		r{{ $retIdx }} = returnFunc({{ $method.ArgCallList }})
	} else {
		{{- if eq "error" (index $method.Returns $retIdx).TypeString }}
		r{{ $retIdx }} = ret.Error({{ $retIdx }})
		{{- else if (index $method.Returns $retIdx).Var.Nillable }}
		if ret.Get({{ $retIdx }}) != nil {
			r{{ $retIdx }} = ret.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		}
		{{- else }}
		r{{ $retIdx }} = ret.Get({{ $retIdx }}).({{ (index $method.Returns $retIdx).TypeString }})
		{{- end }}
	}
		{{- end }} {{/* END RETURN RANGE */}}
	{{- end }}
	return {{ range $retIdx, $ret := $method.Returns }}r{{ $retIdx }}{{ if ne $retIdx (len $method.Returns | Add -1) }}, {{ end }}{{ end }}
}

{{/* CREATE EXPECTER METHOD */}}
{{- $ExpecterCallNameInstantiated := printf "%s_%s_Call%s" $mock.MockName $method.Name ($mock | TypeInstantiation) }}
{{- $ExpecterCallNameConstraint := printf "%s_%s_Call%s" $mock.MockName $method.Name ($mock | TypeConstraint) }}

// {{ $mock.MockName }}_{{ $method.Name }}_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method '{{ $method.Name }}'
type {{ $ExpecterCallNameConstraint }} struct {
	*mock.Call
}

{{/* TODO 2024-12-30 */}}

// {{ $method.Name }} is a helper method to define mock.On call
{{- range $method.Params }}
//  - {{.Var.Name}}
{{- end}}
func (_e *{{ $expecterNameInstantiated }}) {{ $method.Name }}({{ range $method.Params }}{{ .Var.Name }} {{ if .Variadic }}...{{end}}interface{}, {{ end }}) *{{ $ExpecterCallNameInstantiated }} {
	return &{{ $ExpecterCallNameInstantiated }}{Call: _e.mock.On("{{$method.Name}}",
			{{- if not $method.IsVariadic }}
				{{- range $method.Params}}{{.Var.Name}},{{end}}
			{{- else }}
				append([]interface{}{
					{{- range $i, $param := $method.Params }}
						{{- if (lt $i (len $method.Params | Add -1 ))}} {{ $param.Var.Name }},
						{{- else }} }, {{ $param.Var.Name }}...
						{{- end }}
					{{- end}} )...
			{{- end }} )}
}

func (_c *{{ $ExpecterCallNameInstantiated }}) Run(run func({{ $method.ArgList }})) *{{ $ExpecterCallNameInstantiated }} {
	_c.Call.Run(func(args mock.Arguments) {
	{{- if not $method.IsVariadic }}
		run({{ $method.ArgCallList }})
	{{- else}}
		{{- $variadicParam := index $method.Params (len $method.Params | Add -1) }}
		{{- $nonVariadicParams := slice $method.Params 0 (len $method.Params | Add -1 )}}
		variadicArgs := make([]{{ $variadicParam.TypeStringVariadicUnderlying }}, len(args) - {{len $nonVariadicParams}})
		for i, a := range args[{{len $nonVariadicParams}}:] {
			if a != nil {
				variadicArgs[i] = a.({{ $variadicParam.TypeStringVariadicUnderlying }})
			}
		}
		run(
		{{- range $i, $param := $method.Params }}
			{{- if (lt $i (len $nonVariadicParams))}}args[{{$i}}].({{ $param.TypeString }}),
			{{- else}}variadicArgs...)
			{{- end}}
		{{- end}}
	{{- end}}
	})
	return _c
}

func (_c *{{ $ExpecterCallNameInstantiated }}) Return({{ $method.ReturnArgList }}) *{{ $ExpecterCallNameInstantiated }} {
	_c.Call.Return({{ $method.ReturnArgNameList }})
	return _c
}

func (_c *{{ $ExpecterCallNameInstantiated }}) RunAndReturn(run func({{ $method.ArgList }}){{ $method.ReturnArgTypeList }}) *{{ $ExpecterCallNameInstantiated }} {
{{- if eq (len $method.Returns) 0 }}
	_c.Run(run)
{{- else}}
	_c.Call.Return(run)
{{- end}}
	return _c
}
{{/* END TODO EXPECTER */}}
{{- end }} {{/* END METHOD RANGE */}}
{{- end }} {{/* END MOCK RANGE */}}

